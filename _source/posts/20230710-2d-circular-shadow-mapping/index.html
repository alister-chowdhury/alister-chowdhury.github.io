<!DOCTYPE html>
<html lang="en">
   
 
<head>
      <meta charset="utf-8">
      <meta name="author" content="Alister Chowdhury">
      <meta name="theme-color" content="#2b2b2b">
      <link href="/css.css" rel="stylesheet">
      <meta property="og:site_name" content="Stuff And Also Things">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="icon" type="image/png" sizes="32x32" href="/res/favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/res/favicon-16x16.png">
      <!-- Google tag (gtag.js) -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1WDZZ2C662"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        // Don't push stuff if we're testing things locally
        if(window.location.hostname == "alister-chowdhury.github.io")
        {
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1WDZZ2C662');
        }
      </script>
   
    <link rel="canonical" href="https://alister-chowdhury.github.io/posts/20230710-2d-circular-shadow-mapping/"/>
    <meta property="og:title" content="2D Circular Shadow Mapping">
    <meta property="og:url" content="https://alister-chowdhury.github.io/posts/20230710-2d-circular-shadow-mapping/">
    <meta property="og:type" content="article">
    <meta property="og:description" content="How to shadow map pointlights in a 2D scene using circles, in a similar way to traditional 3D shadow mapping, then extending that concept to using planes.">
    <meta property="og:image" content="https://alister-chowdhury.github.io/posts/20230710-2d-circular-shadow-mapping/thumbnail.png">
    <meta property="og:article:published_time" content="2023-07-10T00:00:00">
    <meta property="og:article:tag" content="shadows">
    <meta property="og:article:tag" content="shadow mapping">
    <meta property="og:article:tag" content="lights">
    <meta property="og:article:tag" content="circles">
    <meta property="og:article:tag" content="visibility">
    <meta property="og:article:tag" content="2D">
    <meta property="og:article:tag" content="rendering">
    <meta property="og:article:tag" content="graphics">
    <meta property="og:article:tag" content="depth">
<script data-rh="true" type="application/ld+json">{"@context":"http://schema.org","@type":"Article","author":[{"@type":"Person","name":"By Alister Chowdhury"}],"name":"2D Circular Shadow Mapping","url":"https://alister-chowdhury.github.io/posts/20230710-2d-circular-shadow-mapping/","description":"How to shadow map pointlights in a 2D scene using circles, in a similar way to traditional 3D shadow mapping, then extending that concept to using planes.","thumbnailUrl":"https://alister-chowdhury.github.io/posts/20230710-2d-circular-shadow-mapping/thumbnail.png","datePublished":"2023-07-10T00:00:00"}</script>

    <title>2D Circular Shadow Mapping</title>
    <meta name="description" content="How to shadow map pointlights in a 2D scene using circles, in a similar way to traditional 3D shadow mapping, then extending that concept to using planes.">
    <meta name="keywords" content="shadows, shadow mapping, lights, circles, visibility, 2D, rendering, graphics, depth">

    <script>
        window.circularMappingModuleLoaded = false;
        window.afterCircularMappingModuleLoaded = [];

        function addAfterCircularMappingModuleLoaded(f)
        {
            if(!window.circularMappingModuleLoaded)
            {
                window.afterCircularMappingModuleLoaded.push(f);
            }
            else
            {
                f();
            }
        }
    </script>
    <script type="module">
        import { bindCircularMappingContext } from './circular_mapping.js';
        window.bindCircularMappingContext = bindCircularMappingContext;
        window.circularMappingModuleLoaded = true;
        window.afterCircularMappingModuleLoaded.forEach(f => {f()});
    </script>

    <style>
        .amdAsmCmp
        {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: center;
        }

        .amdAsmCmp > div
        {
            border: #7373c3 1px solid;
            margin: 5px;
        }

        .imComp > div > img
        {
            width: 300px;
            width: 300px;
        }

        canvas
        {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
    </style>

 
<link rel="stylesheet" href="/thirdparty/highlight.js.css">
</head>
   
 
<body>
    <div id="header">
        <a href="/">Home</a>
        <a href="/posts/">Posts</a>
        <a href="https://github.com/alister-chowdhury">Github</a>
    </div>
   


<main>
<h1>2D Circular Shadow Mapping</h1>
<h2>Background</h2>
<p>Lighting a scene efficiently is pretty difficult in 3D and in 2D that is still the case.
The de-facto standard for shadows has remained shadow mapping (and derivative techniques) for quite a number of years and that doesn't look like it will change any time soon.</p>
<p>For 3D, you'd typically render the scene from the perspective of a light (or if it's a directional light, a cascade of orthographic projections that cover what the player can see), storing only the depth and sampling it when it comes time to apply lighting.</p>
<p>We can do a similar thing for pointlights in 2D, by mapping the surface of a circle to a 1D texture.</p>
<pre><code class="language-glsl">// u is the 1d texture coordinate (0 -&gt; 1)
vec2 circlePosition = vec2(cos(u * TWOPI), sin(u * TWOPI));
float u = atan2(circlePosition.y, circlePosition.x) / TWOPI;
</code></pre>
<div id="circleToLineDemoContainer">
<canvas id="circleToLineDemo"></canvas>
<div class="twoxnctrls">
<!----><div>
<!--    --><div id="circleToLineDemoLerpLabel">line &lt;=&gt; circle</div>
<!--    --><div><input aria-labelledby="circleToLineDemoLerpLabel" id="circleToLineDemoLerp" type="range" min="0" max="1" value="0" step="0.0001" style="display:table-cell; width:100%"><br/></div>
<!----></div>
</div>
<p>Storing information in this way has the added bonus, that we can store the shadow information of multiple lights in a single 2D texture, where each light is it's own row.
So if we have 100 lights and we choose to have a resolution of 512, we allocate a single <code>512x100</code> texture, this simplifies binding and opens the door for evaluating all pointlights in a single pass.</p>
<p><strong>If you have truly static lights, baking them all down either onto the background image or as a seperate overlay is always going to be faster at runtime.</strong></p>
<h2>Faster atan2</h2>
<p>You may know that <code>atan2</code> is expensive, especially if it's something we plan on doing potentially multiple times per pixel.
As such, we are going to want to use approximations.</p>
<p>This is a pretty decent one I've found, courtesy of <a target="_blank" href="https://math.stackexchange.com/a/1105038">njuffa on math.stackexchange.com</a>.</p>
<details>
<summary>fastAtan2</summary>
<pre><code class="language-glsl">// https://math.stackexchange.com/a/1105038
float fastAtan2(float y, float x)
{
    float a = min(abs(x), abs(y)) / max(abs(x), abs(y));
    float s = a * a;
    float r = ((-0.0464964749 * s + 0.15931422) * s - 0.327622764) * s * a + a;
    if(abs(y) &gt; abs(x)) { r = HALFPI - r; }
    if(x &lt; 0) { r = PI - r; }
    r = multiplySign(r, y); // if(y &lt; 0) { r = -r; }
    return r;
}
</code></pre>
</details>
<p>But we can do a bit better since we also need to do an extra division by 2pi</p>
<details>
<summary>fastAtan2_div2pi</summary>
<pre><code class="language-glsl">// Similar to fastAtan2, except the result is pre divided by 2pi, for the
// purpose of sampling 1d circular maps (circular shadows etc).
// https://www.geogebra.org/calculator/dms6kp8w
//
// max error ~ 0.00024531353567275316
float fastAtan2_div2pi(float y, float x)
{
    float a = min(abs(x), abs(y)) / max(abs(x), abs(y));
    float s = a * a;
    float r = ((0.013506162438972577 * s + -0.04684240210645093) * s + -0.8414151531876038) * a + a;
    if(abs(y) &gt; abs(x)) { r = 0.25 - r; }
    if(x &lt; 0.0) { r = 0.5 - r; }
    r = multiplySign(r, y); // if(y &lt; 0) { r = -r; }
    return r;
}

</code></pre>
</details>
<p>And if we wanted to be extra accurate (we don't):</p>
<details>
<summary>fastAtan2_div2pi_accurate</summary>
<pre><code class="language-glsl">// One extra mad over fastAtan2_div2pi, although that is typically accurate enough.
//
// max error ~ 3.6957397769599165e-05
float fastAtan2_div2pi_accurate(float y, float x)
{
    float a = min(abs(x), abs(y)) / max(abs(x), abs(y));
    float s = a * a;
    float r = (((-0.0066609612639593 * s + 0.023972538405749075) * s + -0.05140823187987065) * s + -0.8409411267732256) * a + a;
    if(abs(y) &gt; abs(x)) { r = 0.25 - r; }
    if(x &lt; 0.0) { r = 0.5 - r; }
    r = multiplySign(r, y); // if(y &lt; 0) { r = -r; }
    return r;
}
</code></pre>
</details>
<p>I wrote the following python script using <code>scipy.optimize.curve_fit</code> to derive the coefficients (not particularly well written, but this is very much something you run once and never touch again, but probably nice to have a reference):</p>
<details>
<summary>atan01.py</summary>
<pre><code class="language-python">from numpy import *
from scipy.optimize import curve_fit

ACCURATE = False

if ACCURATE:
    def atan01_func(X, *betas):
        a = X # y/x
        s = a * a
        return (((betas[0] * s + betas[1]) * s + betas[2]) * s + betas[3]) * a + a

else:
    def atan01_func(X, *betas):
        a = X # y/x
        s = a * a
        return ((betas[0] * s + betas[1]) * s + betas[2]) * a + a


if __name__ == &quot;__main__&quot;:
    B = linspace(0.0, 1.0, 20000)
    P = stack((cos(B * 2 * pi), sin(B * 2 * pi)))
    Px = P[0]
    Py = P[1]

    # Lazily isolate one quadrant of a cicle
    keep = (Px &gt; 0) &amp; (Py &gt; 0) &amp; (Px &gt; Py)
    Px = Px[keep]
    Py = Py[keep]

    # Fitting ratio of segment
    fit_x = Py / Px
    fit_y = arctan2(Py, Px) / (2 * pi)

    best = float(&quot;inf&quot;)
    best_coefs = None

    for _ in range(10):
        if ACCURATE:
            initial_seed = random.random(4) * 20 - 10
        else:
            initial_seed = random.random(3) * 20 - 10
        try:
            coefs = curve_fit(atan01_func, fit_x, fit_y, initial_seed)[0]
        except RuntimeError:
            # Ignore when convergence couldn't be resolved
            continue
        yhat = atan01_func(fit_x, *coefs)
        diff = abs(fit_y - yhat).max()
        if diff &lt; best:
            best = diff
            best_coefs = coefs

    print(&quot;ACC {0}&quot;.format(best))
    print(&quot;\nCoefs:&quot;)
    for f in best_coefs:
        print(f)
</code></pre>
</details>
<p>Before and after AMD assembly for reference:</p>
<div class="amdAsmCmp">
<div>
<pre><code>v_max_f32     v1, abs(v2), abs(v0)
v_rcp_f32     v1, v1
v_min_f32     v3, abs(v2), abs(v0)
v_mul_f32     v1, v1, v3
v_mul_f32     v3, v1, v1
v_mul_f32     v4, 0x3caaae5f, v3
v_add_f32     v4, 0xbdae5a36, v4
v_madak_f32   v4, v3, v4, 0x3e3876e2
v_madak_f32   v4, v3, v4, 0xbea91d04
v_madak_f32   v3, v3, v4, 0x3f7ff738
v_mul_f32     v4, v1, v3
v_madak_f32   v4, -2.0, v4, 0x3fc90fdb
v_cmp_gt_f32  vcc, abs(v0), abs(v2)
v_cndmask_b32  v4, 0, v4, vcc
v_min_f32     v5, v2, v0
v_max_f32     v0, v2, v0
v_cmp_gt_f32  vcc, -v2, v2
v_mov_b32     v2, 0xc0490fdb
v_cmp_gt_f32  s[0:1], -v5, v5
v_cmp_ge_f32  s[2:3], v0, -v0
v_mac_f32     v4, v1, v3
v_cndmask_b32  v0, 0, v2, vcc
s_and_b64     vcc, s[0:1], s[2:3]
v_mov_b32     v1, 0x80000000
v_add_f32     v0, v4, v0
v_cndmask_b32  v1, 0, v1, vcc
v_xor_b32     v0, v0, v1
v_mul_f32     v0, 0.15915494, v0
</code></pre>
</div>
<div>
<pre><code>v_min_f32     v1, abs(v2), abs(v0)
v_max_f32     v3, abs(v2), abs(v0)
v_rcp_f32     v3, v3
v_mul_f32     v1, v1, v3
v_mul_f32     v3, v1, v1
v_mul_f32     v4, 0x3c5d48f3, v3
v_add_f32     v4, 0xbd3fddd2, v4
v_madak_f32   v3, v4, v3, 0xbf5766fc
v_mac_f32     v1, v3, v1
v_sub_f32     v3, 0x3e800000, v1
v_cmp_gt_f32  vcc, abs(v2), abs(v0)
v_cndmask_b32  v1, v1, v3, vcc
v_sub_f32     v3, 0.5, v1
v_cmp_gt_f32  vcc, 0, v0
v_cndmask_b32  v0, v1, v3, vcc
v_and_b32     v1, 0x80000000, v2
v_xor_b32     v0, v0, v1
</code></pre>
</div>
</div>
<h2>Generating A Shadowmap</h2>
<p>If you've got a BVH of the scene (<a href="https://alister-chowdhury.github.io/posts/20230620-raytracing-in-2d/">Raytracing In 2D</a>), you can very quickly generate your maps.</p>
<pre><code class="language-glsl">// Assuming you're just doing a fullscreen pass with the vertex shader
// that outputs the screen uv coordinate and have a uniform buffer of pointlight
// coordinates.

layout(location=0) in vec2 uv;
layout(location=0) out float outDepth; // Or write to gl_FragDepth, both would work.

void main()
{

    int lightId = int(gl_FragCoord.y);
    vec2 ro = getLightPosition(lightId);
    vec2 rd = vec2(cos(uv.x * TWOPI), sin(uv.x * TWOPI));

    LineBvhV1Result hit = traceLineBvhV1(ro, rd, 1.0, false);

    outDepth = sqrt(hit.hitDistSq);

    // Needs to be normalised between 0-&gt;1 to work
    // gl_FragDepth = 1.0 - 1.0 / (1.0 + length(I));
}
</code></pre>
<p>Now if you aren't interested in generating a BVH, you can also use lines directly, but it is a bit more involved.
The basic idea is to draw each line over each pointlights row, then manually overriding <code>gl_FragDepth</code>, allowing the GPUs depth hardware to store the closest hit.</p>
<p>For this example, I'm using <code>glDrawArraysInstanced</code>, with the vertex id encoding the light and instance id encoding the line.
(We also need to draw each line twice, since it's liable to wrap around).</p>
<details>
<summary>vertex shader</summary>
<pre><code class="language-glsl">layout(location = 0) uniform float invTextureHeight;

flat layout(location = 0) out vec4 lineData;
layout(location = 1) out float direction;


void main()
{
    // Lines need to be duplicated so we can effectively wrap around
    // when projected lines aren't simply in the 0-&gt;1 range and are in the
    // -1-&gt;0 range.
    const float polarOffset = float(gl_InstanceID &amp; 1);
    const uint pointLightID = startingPointLightID + gl_InstanceID &gt;&gt; 1;

    const uint lineId = gl_VertexID &gt;&gt; 1;
    const uint lineSide = gl_VertexID &amp; 1;

    const vec2 light = getLightPosition(pointLightID);
    vec4 line = getLine(lineId) - light.xyxy; // Make sure the line is always relative to the light

    // x = A, y = B
    vec2 polarPositions = vec2(fastAtan2_div2pi(line.y, line.x),
                               fastAtan2_div2pi(line.w, line.z));


    // Make sure the points are the minimum circular distance
    #if 0 // reference
        if(polarPositions.y &lt; polarPositions.x) {
            polarPositions.x -= sign(polarPositions.x) * float(abs(polarPositions.y - polarPositions.x) &gt; 0.5);
        }
        else {
            polarPositions.y -= sign(polarPositions.y) * float(abs(polarPositions.x - polarPositions.y) &gt; 0.5);
        }
    #else // branchless
        polarPositions -= (
            vec2(lessThan(polarPositions.yx, polarPositions.xy))
            * sign(polarPositions)
            * vec2(greaterThan(abs(polarPositions - polarPositions.yx), vec2(0.5)))
        );
    #endif

    // In order to make everything airtight (so no holes where lines meet)
    // the lines need to have a consistent winding order, to get around
    // this, we can instead opt to make sure our line coords are sorted.
    if(polarPositions.y &lt; polarPositions.x)
    {
        float tmp = polarPositions.x;
        polarPositions.x = polarPositions.y;
        polarPositions.y = tmp;

        vec2 tmpl = line.xy;
        line.xy = line.zw;
        line.zw = tmpl;
    }

    // Apply wrap-around offset
    polarPositions += polarOffset;

    // Swap between A and B points
    const float X = ((lineSide == 0) ? polarPositions.x : polarPositions.y);

    lineData = ((lineSide == 0) ? line.xyzw : line.zwxy);
    direction = TWOPI * (X - 0.5);

    gl_Position = vec4(2 * X - 1,
                       2 * ((0.5 + float(pointLightID)) * invTextureHeight) - 1,
                       0.0,
                       1.0);
}
</code></pre>
</details>
<br>
<details>
<summary>fragment shader</summary>
<pre><code class="language-glsl">flat layout(location = 0) in vec4 lineData;
layout(location = 1) in float direction;

void main()
{
    // Calculate the distance from the origin when facing in a direction
    // dictated by the polar coordinates to the target line.
    // https://www.geogebra.org/m/pabfs2c9
    vec2 directionVec = vec2(cos(direction), sin(direction));

    vec2 lineDiff = lineData.zw - lineData.xy;
    float u = (
        (directionVec.x * lineData.y - directionVec.y * lineData.x)
        / (lineDiff.x * directionVec.y - lineDiff.y * directionVec.x)
    );

    vec2 I = lineData.xy + lineDiff * u;
    gl_FragDepth = 1.0 - 1.0 / (1.0 + length(I));
}
</code></pre>
</details>
<p>Overall, using the BVH version is probably a better option.</p>
<p>Now we can start attempting to shadow things.
Normally for shadow maps you'd use something like PCF when sampling, which we can get the hardware to do directly
when using a depth texture (it's not hard to do manually if you're rendering to some other format).</p>
<details>
<summary>texture parameters</summary>
<pre><code class="language-c">glTextureParameteri(tex, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTextureParameteri(tex, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

if(useHardwarePCF)
{
    glTextureParameteri(tex, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTextureParameteri(tex, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTextureParameteri(tex, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);
    glTextureParameteri(tex, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE);
}

// manual PCF
else
{
    glTextureParameteri(tex, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTextureParameteri(tex, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
}
</code></pre>
</details>
<p>For the sake of keeping this simple, I'll assume we're using a depth texture and here are the parameters to enable PCF.</p>
<p>Here is one way, you might go about applying the lights in a single fullscreen pass:</p>
<details>
<summary>lighting pass</summary>
<pre><code class="language-glsl">layout(location = 0) uniform uint pointLightCount;
layout(binding = 0) uniform sampler2DShadow pointLightShadowMap;

layout(location = 0) in vec2 uv;
layout(location = 0) out vec4 outRgba;

void main()
{

    const vec2 invTextureSize = 1.0 / vec2(textureSize(pointLightShadowMap, 0));
    const float textureWidth = vec2(textureSize(pointLightShadowMap, 0)).x;

    vec3 totalAccum = vec3(0.0);

    for(uint pointLightID=0; pointLightID &lt; pointLightCount; ++pointLightID)
    {

        const vec2 pointLightPos = getLightPosition(pointLightID);
        const vec2 localUv = (2.0 * uv - 1.0) - pointLightPos.xy;   // assuming lights are in NDC space

        const float X = fastAtan2_div2pi(localUv.y, localUv.x);
        const float Y = (0.5 + float(pointLightID)) * invTextureSize.y;
        const float Z = 1.0 - 1.0 / (1.0 + length(localUv));
        float pcf = texture(pointLightShadowMap, vec3(X, Y, Z));
        totalAccum += evaluateLight(pointLightID, localUv) * pcf;
    }

    outRgba = vec4(totalAccum, 1.0);
}
</code></pre>
</details>
<br>
<div class="imTable imComp">
  <div><img alt="example1" src="res/example1.png"><br>Single light source</div>
</div>
<br>
<p>This may all look fine at first, but all is not how it seems...<br>
If we move our light source and zoom in a bit, the true horror of acne reveals itself.</p>
<div class="imTable imComp">
  <div><img alt="acne0" src="res/acne0.png"><br>Reference</div>
  <div><img alt="acne1" src="res/acne1.png"><br>Zoomed in #1</div>
  <div><img alt="acne2" src="res/acne2.png"><br>Zoomed in #2</div>
</div>
<br>
<p>This does make sense, since each sample more-or-less maps to a radius of visibility and any direction in between doesn't really correspond to either in a linear way.</p>
<p>You can of course just up the resolution, but this isn't a very satisfying solution.</p>
<p>You might attempt to create lines between depth samples and then do line-line intersection tests, or even just render a line directly and this
does work to some extent, but looks pretty bad when you get to the lines end points.</p>
<p>A nicer solution I've found is to use <a target="_blank" href="https://en.wikipedia.org/wiki/Hesse_normal_form">Hesse Normal Form</a> (basically planes).</p>
<h2>Planemaps</h2>
<p>The idea is to store the equation of the line rather than its distance.
It's not massively different pipeline wise to make the switch, although a bit more involved.</p>
<p>Using <code>R10G10B10A2</code> is a natural fit, with <code>N</code> being stored in <code>RG</code> and <code>dist</code> being stored in <code>B</code>
(not currently using <code>A</code>, but it could easily be used to store a more precise <code>dist</code>).</p>
<p>We could also opt for <code>RG16F</code>, storing a polar angle in <code>R</code> and the dist in <code>G</code>.</p>
<p>As a reminder, no GPU actually supports the &quot;regular&quot; three-component texture formats (<code>RGB8</code>, <code>RGB16</code>, <code>RGB16F</code>, <code>RGB32F</code>), they
are simply padded and the hidden <code>A</code> is basically dead space.</p>
<pre><code class="language-glsl">layout(location=0) in vec2 uv;
layout(location=0) out vec4 outPlane;

void main()
{
    int lightId = int(gl_FragCoord.y);
    vec2 ro = getLightPosition(lightId);
    vec2 rd = vec2(cos(uv.x * TWOPI), sin(uv.x * TWOPI));
    LineBvhV1Result hit = traceLineBvhV1(ro, rd, 1.0, false);

    vec2 N = rd;
    float w = 1.0;

    if(hit.hitLineId != 0xffffffffu)
    {
        N = normalize(vec2(hit.line.w, -hit.line.z));
        w = dot(N, hit.line.xy - ro);

        // Ensure a consistent clockwise orientation plus
        // keep the distance coef positive.
        N.x = multiplySign(N.x, w);
        N.y = multiplySign(N.y, w);
        w = multiplySign(w, w);
    }

    // R10G10B10A2 encoding, A2 is currently unused...
    outPlane = vec4(N * 0.5 + 0.5, w, 1.0);
}
</code></pre>
<p>When it comes to sampling, there are two flavours that I've found work well.</p>
<h3>Binary sampling</h3>
<p>This is by far the simplest method and works rather well, it can feel a bit jittery though and break down a tad
when there is a sharp change in orientation.</p>
<pre><code class="language-glsl">float getBinaryPlaneVisibility(vec2 uv, vec3 sampledNormalAndDistance, float bias /* = 0.5 / lightPlaneMapSize.x */)
{
    return 1.0 - smoothstep(sampledNormalAndDistance.z - bias,
                            sampledNormalAndDistance.z + bias,
                            dot(uv, sampledNormalAndDistance.xy));
}
</code></pre>
<h3>PCF</h3>
<p>Can look better when the linemap resolution is very low, but overall <strong>Binary sampling</strong> should probably be preferred.</p>
<pre><code class="language-glsl">// Two taps and two binary plane tests, texture width is assumed to be a power of 2,
// more expensive, but generally just looks better.
float getPCFPlaneVisibility(sampler2D lightPlaneMap,
                            vec2 localUv, // uv local to the lights center
                            vec2 planeMapUV,
                            ivec2 lightPlaneMapSize,
                            float bias /* = 0.5 / lightPlaneMapSize.x */)
{
    float sampleXBase = (planeMapUV.x + 1.0) * lightPlaneMapSize.x - 0.5;
    int sampleY = int(planeMapUV.y * lightPlaneMapSize.y);

    int sampleX0 = int(sampleXBase);
    int sampleX1 = sampleX0 + 1;
    sampleX0 &amp;= (lightPlaneMapSize.x - 1);
    sampleX1 &amp;= (lightPlaneMapSize.x - 1);

    vec3 planeAndDistance0 = texelFetch(lightPlaneMap, ivec2(sampleX0, sampleY), 0).xyz;
    vec3 planeAndDistance1 = texelFetch(lightPlaneMap, ivec2(sampleX1, sampleY), 0).xyz;
    planeAndDistance0.xy = planeAndDistance0.xy * 2.0 - 1.0;
    planeAndDistance1.xy = planeAndDistance1.xy * 2.0 - 1.0;

    float visbility0 = getBinaryPlaneVisibility(localUv, planeAndDistance0, bias);
    float visbility1 = getBinaryPlaneVisibility(localUv, planeAndDistance1, bias);

    float lerpWeight = fract(sampleXBase);
          lerpWeight = smoothstep(0, 1, lerpWeight);
    return mix(visbility0, visbility1, lerpWeight);
}
</code></pre>
<h2>Filtering Lights To Evaluate</h2>
<p>Up until this point, we've been evaluating every light per pixel, this is not going to scale well beyond a handful of lights.</p>
<p>The first obvious optimisation would be to only evaluate pixels the player sees (<a href="https://alister-chowdhury.github.io/posts/20230628-project-and-stencil/">Blocking 2D Player Visibility</a>), although this might not always be possible.</p>
<p>We can generate bounds for each light, using the planemaps we've already generated and draw a series of quads which add the colour to the scene.</p>
<p>(If we weren't targeting WebGL and had compute shaders / UAV buffers, using a linked light list would be a sensible option).</p>
<p>The simplest option is to generate BBOXs:</p>
<details>
<summary>gen_bbox.frag</summary>
<pre><code class="language-glsl">vec2 projectRay(vec3 planeAndDistance, float theta)
{
    vec2 rd = vec2(cos(theta), sin(theta));
    float denom = dot(planeAndDistance.xy, rd);

    // Prevent divisions by zero and excessive expansion at grazing angles
    float onedeg = 0.01745240643728351;
    if(abs(denom) &lt;= onedeg)
    {
        return vec2(0);
    }

    float distToPlane = planeAndDistance.z / denom;
    return rd * distToPlane;
}


void main()
{
    int lineIndex = int(gl_FragCoord.x);
    vec2 ro = getLightPosition(lightingData, lineIndex);
    vec2 bboxMax = vec2(-65504.0);
    vec2 bboxMin = vec2(65504.0);

    // Assumed linemap resolution to be a power of 2
    int lightPlaneMapWidth = textureSize(lightPlaneMap, 0).x;
    float invTextureSizeTwoPi = rcpForPowersOf2(float(lightPlaneMapWidth)) * TWOPI;

    for(int x=0; x &lt; lightPlaneMapWidth; ++x)
    {

        vec3 planeAndDistance = texelFetch(lightPlaneMap, ivec2(x, lineIndex), 0).xyz;
             planeAndDistance.xy = planeAndDistance.xy * 2 - 1;

        // Project against the left and right rotational values
        // to prevent underprojecting and not fully containing
        // the light.

        const float bias = 1.0;

        float thetaLeft = (float(x) - bias) * invTextureSizeTwoPi;
        float thetaRight = (float(x) + bias) * invTextureSizeTwoPi;

        vec2 projectionLeft = projectRay(planeAndDistance, thetaLeft);
        vec2 projectionRight = projectRay(planeAndDistance, thetaRight);

        bboxMin = min(min(projectionLeft, projectionRight), bboxMin);
        bboxMax = max(max(projectionLeft, projectionRight), bboxMax);
    }

    outBBox = vec4(bboxMin + ro, bboxMax + ro);
}
</code></pre>
</details>
<br>
<p>This works reasonably well, but we can prevent overdrawing by fitting a better quad:</p>
<details>
<summary>gen_obbox.frag</summary>
<pre><code class="language-glsl">vec2 projectRay(vec3 planeAndDistance, float theta)
{
    vec2 rd = vec2(cos(theta), sin(theta));
    float denom = dot(planeAndDistance.xy, rd);

    // Prevent divisions by zero and excessive expansion at grazing angles
    float onedeg = 0.01745240643728351;
    if(abs(denom) &lt;= onedeg)
    {
        return vec2(0);
    }

    float distToPlane = planeAndDistance.z / denom;
    return rd * distToPlane;
}


void main()
{
    int lineIndex = int(gl_FragCoord.x);
    vec2 ro = getLightPosition(lightingData, lineIndex);

    // Assumed linemap resolution to be a power of 2
    int lightPlaneMapWidth = textureSize(lightPlaneMap, 0).x;
    float invTextureSizeTwoPi = rcpForPowersOf2(float(lightPlaneMapWidth)) * TWOPI;

    const float bias = 1.0;

    // Find initial furthest vector
    vec2 furthest = vec2(0);
    float furthestDistSq = -65504.0;

    for(int x=0; x &lt; lightPlaneMapWidth; ++x)
    {
        vec3 planeAndDistance = texelFetch(lightPlaneMap, ivec2(x, lineIndex), 0).xyz;
             planeAndDistance.xy = planeAndDistance.xy * 2 - 1;

        float thetaLeft = (float(x) - bias) * invTextureSizeTwoPi;
        vec2 projectionLeft = projectRay(planeAndDistance, thetaLeft);
        float leftDistSq = dot(projectionLeft, projectionLeft);
        float thetaRight = (float(x) + bias) * invTextureSizeTwoPi;
        vec2 projectionRight = projectRay(planeAndDistance, thetaRight);
        float rightDistSq = dot(projectionRight, projectionRight);

        if(leftDistSq &gt; furthestDistSq)
        {
            furthest = projectionLeft;
            furthestDistSq = leftDistSq;
        }

        if(rightDistSq &gt; furthestDistSq)
        {
            furthest = projectionRight;
            furthestDistSq = rightDistSq;
        }
    }

    // Next find the furthest point from our first point
    vec2 furthestTangent = vec2(0);
    float furthestTangentDistSq = -65504.0;

    for(int x=0; x &lt; lightPlaneMapWidth; ++x)
    {
        vec3 planeAndDistance = texelFetch(lightPlaneMap, ivec2(x, lineIndex), 0).xyz;
             planeAndDistance.xy = planeAndDistance.xy * 2 - 1;

        float thetaLeft = (float(x) - bias) * invTextureSizeTwoPi;
        vec2 projectionLeft = projectRay(planeAndDistance, thetaLeft);
        float leftDistSq = dot(projectionLeft - furthest, projectionLeft - furthest);
        float thetaRight = (float(x) + bias) * invTextureSizeTwoPi;
        vec2 projectionRight = projectRay(planeAndDistance, thetaRight);
        float rightDistSq = dot(projectionRight - furthest, projectionRight - furthest);

        if(leftDistSq &gt; furthestTangentDistSq)
        {
            furthestTangent = projectionLeft;
            furthestTangentDistSq = leftDistSq;
        }

        if(rightDistSq &gt; furthestTangentDistSq)
        {
            furthestTangent = projectionRight;
            furthestDistSq = rightDistSq;
        }
    }

    vec2 L0 = furthest;
    vec2 L1 = furthestTangent;

    // All remaining points should lie either left or right of our computed line
    float CDist = 0.0;
    float DDist = 0.0;

    vec2 Ld = normalize(L1 - L0);
    vec2 Ln = vec2(Ld.y, -Ld.x);
    float Lw = dot(Ln, L0);

    for(int x=0; x &lt; lightPlaneMapWidth; ++x)
    {
        vec3 planeAndDistance = texelFetch(lightPlaneMap, ivec2(x, lineIndex), 0).xyz;
             planeAndDistance.xy = planeAndDistance.xy * 2 - 1;

        float thetaLeft = (float(x) - bias) * invTextureSizeTwoPi;
        vec2 projectionLeft = projectRay(planeAndDistance, thetaLeft);
        float leftDist = dot(projectionLeft, Ln) - Lw;

        float thetaRight = (float(x) + bias) * invTextureSizeTwoPi;
        vec2 projectionRight = projectRay(planeAndDistance, thetaRight);
        float rightDist = dot(projectionRight, Ln) - Lw;

        if(leftDist &lt; 0)
        {
            if(abs(leftDist) &gt; abs(CDist))
            {
                CDist = leftDist;
            }
        }
        else
        {
            if(leftDist &gt; DDist)
            {
                DDist = leftDist;
            }
        }

        if(rightDist &lt; 0)
        {
            if(abs(rightDist) &gt; abs(CDist))
            {
                CDist = rightDist;
            }
        }
        else
        {
            if(rightDist &gt; DDist)
            {
                DDist = rightDist;
            }
        }
    }

    vec2 A = furthest + Ln * CDist;
    vec2 B = furthest + Ln * DDist;
    vec2 C = furthestTangent + Ln * DDist;
    vec2 D = furthestTangent + Ln * CDist;

    outOOBox = uvec4(packHalf2x16(A + ro),
                     packHalf2x16(B + ro),
                     packHalf2x16(C + ro),
                     packHalf2x16(D + ro));
}
</code></pre>
</details>
<br>
<p>The above stores four points, but in order to make it easier to fetch, packs them as <code>float16</code>.</p>
<br>
<p>Despite the <code>bbox</code> code iterating every pixel in a row (and the <code>obbox</code> iterating them three times), this is actually
remarkably not the most obscenely expensive operation to run, of course ideally you'd run the whole operation maybe once
and update individual lights as data changes.</p>
<p>If we have stationary lights which change intensity / colour, but not be moved, offline generating polygons and not using
shadow mapping at all would result in the fastest solution (although that's not exactly simple to do and very beyond the scope
of what we're attempting to do here).</p>
<p>Regardless, one of the main bottlenecks to expect here is the amount of lights that overlap the same pixel, as this increases the
amount of implicit dependencies the GPU will need to resolve when blending (a complex scene may then actually be cheaper to evaluate).</p>
<p>Anyway, this post has gone on for long enough, here is a mini demo (drag to move lights around):</p>
<div>
<canvas id="drawCanvas" style="width:500px;height:500px;" width=500 height=500></canvas><br/>
<div class="twoxnctrls" id="drawCanvasControls">
<!----><div>
<!--    --><div id="resolutionCtrlDivLabel">Resolution</div>
<!--    --><div><input aria-labelledby="resolutionCtrlDivLabel" id="resolutionCtrl" disabled type="number" min="1" max="2048" value="500" step="1" style="display:table-cell; width:100%"><br/></div>
<!----></div>
<!----><div>
<!--    --><div id="lineMapResCtrlDivLabel">Linemap Resolution</div>
<!--    --><div><div><input aria-labelledby="lineMapResCtrlDivLabel" id="lineMapResCtrl" disabled type="range" min="5" max="11" value="9" step="1" style="display:table-cell; width:100%"><div id="lineMapResVis">512</div></div><br/></div>
<!----></div>
<!----><div>
<!--    --><div id="lightCountCtrlDivLabel"># Lights</div>
<!--    --><div><input aria-labelledby="lightCountCtrlDivLabel" id="lightCountCtrl" disabled type="range" min="1" max="100" value="10" step="1" style="display:table-cell; width:100%"><div id="numLightsVis">10</div><br/></div>
<!----></div>
<!----><div>
<!--    --><div id="drawLinesOverlayLabel">Draw lines</div>
<!--    --><div><input aria-labelledby="drawLinesOverlayLabel" id="drawLinesOverlayCtrl" disabled type="checkbox" checked style="display:table-cell; width:100%"><br/></div>
<!----></div>
<!----><div>
<!--    --><div id="drawBoundsOverlayLabel">Draw bounds</div>
<!--    --><div><input aria-labelledby="drawBoundsOverlayLabel" id="drawBoundsOverlayCtrl" disabled type="checkbox" style="display:table-cell; width:100%"><br/></div>
<!----></div>
<!----><div>
<!--    --><div>Scene</div>
<!--    --><div class="knkRadio">
<!--        --><input disabled type="radio" id="sceneType-simple" name="sceneType" checked="checked"><label for="sceneType-simple">Simple</label>
<!--        --><input disabled type="radio" id="sceneType-moderate" name="sceneType"><label for="sceneType-moderate">Moderate</label>
<!--        --><input disabled type="radio" id="sceneType-complex" name="sceneType"><label for="sceneType-complex">Complex</label>
<!--    --></div>
<!----></div>
<!----><div>
<!--    --><div>Bounds type</div>
<!--    --><div class="knkRadio">
<!--        --><input disabled type="radio" id="boundsType-bbox" name="boundsType"><label for="boundsType-bbox">BBOX</label>
<!--        --><input disabled type="radio" id="boundsType-obbox" name="boundsType" checked="checked"><label for="boundsType-obbox">OBBOX</label>
<!--    --></div>
<!----></div>
<!----><div>
<!--    --><div>Filtering</div>
<!--    --><div class="knkRadio">
<!--        --><input disabled type="radio" id="filtering-binary" name="filtering"><label for="filtering-binary">Binary</label>
<!--        --><input disabled type="radio" id="filtering-pcf" name="filtering" checked="checked"><label for="filtering-pcf">PCF</label>
<!--    --></div>
<!----></div>
<!----><div>
<!--    --><div id="lightSelectCtrlDivLabel">Select light</div>
<!--    --><div><input aria-labelledby="lightSelectCtrlDivLabel" id="lightSelectCtrl" disabled type="range" min="0" max="49" value="0" step="1" style="display:table-cell; width:100%"><br/></div>
<!----></div>
<!----><div>
<!--    --><div id="lightColCtrlDivLabel">Light Colour</div>
<!--    --><div><input aria-labelledby="lightColCtrlDivLabel" id="lightColCtrl" disabled type="color" value="#000000"><br/></div>
<!----></div>
<!----><div>
<!--    --><div id="lightIntensityCtrlDivLabel">Intensity</div>
<!--    --><div><input aria-labelledby="lightIntensityCtrlDivLabel" id="lightIntensityCtrl" disabled type="range" min="0" max="10" value="1" step="0.01" style="display:table-cell; width:100%"><br/></div>
<!----></div>
<!----><div>
<!--    --><div id="lightDecayRateCtrlDivLabel">Decay Rate</div>
<!--    --><div><input aria-labelledby="lightDecayRateCtrlDivLabel" id="lightDecayRateCtrl" disabled type="range" min="0.01" max="10" value="0" step="0.01" style="display:table-cell; width:100%"><br/></div>
<!----></div>
</div>
<div id="notSupportedBrowser"></div>
</div>
<ul>
<li>JS used for demo: <a target="_blank" href="https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/circular_mapping.js">circular_mapping.js</a></li>
<li>Shader used for demo:</li>
<li><ul>
<li>Plane generation: <a target="_blank" href="https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/gen_plane_map.frag">gen_plane_map.frag</a></li>
</ul>
</li>
<li><ul>
<li>BBox calculation: <a target="_blank" href="https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/gen_bbox.frag">gen_bbox.frag</a></li>
</ul>
</li>
<li><ul>
<li>OBBox calculation: <a target="_blank" href="https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/gen_obbox.frag">gen_obbox.frag</a></li>
</ul>
</li>
<li><ul>
<li>Light drawing: <a target="_blank" href="https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/draw_lights.frag">draw_lights.frag</a>, <a target="_blank" href="https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/draw_lights.vert">draw_lights.vert</a>, <a target="_blank" href="https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/lights_common.glsli">lights_common.glsli</a></li>
</ul>
</li>
</ul>

  </main>


<script>
    // Hook up the circle to line demo
    const initCircleToLineDemo = ()=>
    {
        const width = 300;
        const height = 300;
        const canvas = document.getElementById("circleToLineDemo");
        const lerpCtrl = document.getElementById("circleToLineDemoLerp");
        const circleSize = 5;
        const ctx = canvas.getContext("2d");
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        canvas.width = width;
        canvas.height = height;

        const redrawCircleToLineDemo = ()=>
        {
            const lerp = lerpCtrl.value;
            const numPoints = 20;
            const normFactorLine = 1.0 / numPoints;
            const normFactorCicle = normFactorLine * (2 * Math.PI);

            ctx.clearRect(0, 0, width, height);
            ctx.rect(0, 0, width, height);
            ctx.fillStyle = "#400778";
            ctx.fill();

            const hs1 = (H)=>{
                const saturateHex = (x)=>  (
                    (Math.floor(0.5 + 255 * Math.max(0, Math.min(1, x))))
                    .toString(16)
                    .padStart(2, "0")
                );
                const R = saturateHex(Math.abs(H * 6 - 3) - 1);
                const G = saturateHex(2 - Math.abs(H * 6 - 2));
                const B = saturateHex(2 - Math.abs(H * 6 - 4));
                return "#"+R+G+B;
            };

            for(let i=0; i<numPoints; ++i)
            {
                const center = (i + 0.5);
                const lineX = center * normFactorLine;
                const lineY = 0.5;
                const circleX = Math.cos(center * normFactorCicle) * 0.5 + 0.5;
                const circleY = Math.sin(center * normFactorCicle) * 0.5 + 0.5;

                // Lerp between the values, then normalise to the wdith, but also
                // account for the size of the point we draw.
                const X = (lineX * (1 - lerp) + circleX * lerp) * (width - circleSize * 2) + circleSize;
                const Y = (lineY * (1 - lerp) + circleY * lerp) * (height - circleSize * 2) + circleSize;

                ctx.beginPath();
                ctx.arc(X, Y, circleSize, 0, 2 * Math.PI);
                ctx.fillStyle = hs1(lineX * 0.5);
                ctx.fill();

            }
        };

        redrawCircleToLineDemo();
        lerpCtrl.onchange = redrawCircleToLineDemo;
        lerpCtrl.oninput = redrawCircleToLineDemo;
    };
    initCircleToLineDemo();

    // Bootstrap the render region to be somewhat reasonable
    {
        let canvasSize = Math.round(
            Math.min(
                (window.innerHeight || document.documentElement.clientHeight),
                (window.innerWidth || document.documentElement.clientWidth)
            ) * 0.6
        );
        const resolutionCtrl = document.getElementById("resolutionCtrl");

        canvasSize = Math.min(resolutionCtrl.max, Math.max(resolutionCtrl.min, Math.round(canvasSize)));
        resolutionCtrl.value = canvasSize;

        const drawCanvas = document.getElementById("drawCanvas");
        drawCanvas.style.width = canvasSize + "px";
        drawCanvas.style.height = canvasSize + "px";
    }

    addAfterCircularMappingModuleLoaded(()=>
    {
        // We can happily start bootstrapping the canvas ahead of all the resources being loaded
        const drawCanvas = document.getElementById("drawCanvas");
        const drawCtx = window.bindCircularMappingContext(drawCanvas);
        if(drawCtx.valid)
        {
            drawCtx.resourceLoaded.then(()=>{
                const resolutionCtrl = document.getElementById("resolutionCtrl");
                resolutionCtrl.disabled = false;
                const updateRes = ()=>
                {
                    const value = Math.min(resolutionCtrl.max, Math.max(resolutionCtrl.min, Math.round(resolutionCtrl.value)));
                    if(resolutionCtrl.value != value)
                    {
                        resolutionCtrl.value = value;
                    }
                    drawCanvas.style.width = value + "px";
                    drawCanvas.style.height = drawCanvas.style.width;
                    drawCtx.redraw();
                };
                resolutionCtrl.onchange = updateRes;

                const lineMapResCtrl = document.getElementById("lineMapResCtrl");
                const lineMapResVis = document.getElementById("lineMapResVis");
                const updateLineMapRes = ()=>
                {
                    const newRes = 1 << lineMapResCtrl.value;
                    lineMapResVis.innerText = newRes;
                    drawCtx.newPlaneMapResolution = newRes;
                    drawCtx.redraw();
                };
                lineMapResCtrl.disabled = false;
                lineMapResCtrl.oninput = updateLineMapRes;
                lineMapResCtrl.onchange = updateLineMapRes;

                const lightCountCtrl = document.getElementById("lightCountCtrl");
                const lightSelectCtrl = document.getElementById("lightSelectCtrl");
                const lightColCtrl = document.getElementById("lightColCtrl");
                const lightIntensityCtrl = document.getElementById("lightIntensityCtrl");
                const lightDecayRateCtrl = document.getElementById("lightDecayRateCtrl");
                const numLightsVis = document.getElementById("numLightsVis");

                const updateLightSelection = ()=>
                {
                    const paddedHexify = x => Math.floor(x * 255.0 + 0.5).toString(16).padStart(2, "0");
                    const encodeColour = x => "#" + paddedHexify(x[0]) + paddedHexify(x[1]) + paddedHexify(x[2]);
                    const light = drawCtx.lights[lightSelectCtrl.value];
                    lightColCtrl.value = encodeColour(light.colour);
                    lightIntensityCtrl.value = light.intensity;
                    lightDecayRateCtrl.value = light.decayRate;
                };
                lightSelectCtrl.disabled = false;
                lightSelectCtrl.onchange = updateLightSelection;
                lightSelectCtrl.oninput = updateLightSelection;
                lightSelectCtrl.max = drawCtx.currentNumLightsToRender - 1;
                lightSelectCtrl.value = 0;
                updateLightSelection();

                const updateNumLines = ()=>
                {
                    const numLights = lightCountCtrl.value * 1;
                    drawCtx.newNumLightsToRender = numLights;

                    if(lightSelectCtrl.value >= numLights)
                    {
                        lightSelectCtrl.value = numLights - 1;
                        updateLightSelection();
                    }

                    lightSelectCtrl.max = numLights - 1;
                    numLightsVis.innerText = numLights;
                    drawCtx.redraw();
                };
                lightCountCtrl.disabled = false;
                lightCountCtrl.max = drawCtx.maxLights;
                lightCountCtrl.value = drawCtx.currentNumLightsToRender;
                lightCountCtrl.onchange = updateNumLines;
                lightCountCtrl.oninput = updateNumLines;
                numLightsVis.innerText = drawCtx.currentNumLightsToRender;

                const lightSettingChanged = ()=>
                {
                    const idx = lightSelectCtrl.value
                    const light = drawCtx.lights[idx];
                    const parseColor = (x)=>[parseInt(x.substring(1, 3), 16) / 255.0,
                                             parseInt(x.substring(3, 5), 16) / 255.0,
                                             parseInt(x.substring(5, 7), 16) / 255.0];
                    
                    light.colour = parseColor(lightColCtrl.value);
                    light.intensity = lightIntensityCtrl.value;
                    light.decayRate = lightDecayRateCtrl.value;

                    drawCtx.dirtyLights.push(idx);
                    drawCtx.redraw();
                };

                lineMapResCtrl.disabled = false;
                lineMapResCtrl.oninput = updateLineMapRes;
                lineMapResCtrl.onchange = updateLineMapRes;

                [lightColCtrl, lightIntensityCtrl, lightDecayRateCtrl].forEach(x=>
                {
                    x.disabled = false;
                    x.oninput = lightSettingChanged;
                    x.onchange = lightSettingChanged;
                });


                const drawLinesOverlayCtrl = document.getElementById("drawLinesOverlayCtrl");
                drawLinesOverlayCtrl.disabled = false;
                drawLinesOverlayCtrl.onchange = ()=>{
                    drawCtx.drawLines = drawLinesOverlayCtrl.checked;
                    drawCtx.redraw();
                };

                const drawBoundsOverlayCtrl  = document.getElementById("drawBoundsOverlayCtrl");
                drawBoundsOverlayCtrl.disabled = false;
                drawBoundsOverlayCtrl.onchange = ()=>{
                    drawCtx.drawBounds = drawBoundsOverlayCtrl.checked;
                    drawCtx.redraw();
                };

                const sceneCtrlSuffixs = ["simple", "moderate", "complex"];
                for(let i=0; i<sceneCtrlSuffixs.length; ++i)
                {
                    const fossilizedIndex = i;
                    const element = document.getElementById("sceneType-" + sceneCtrlSuffixs[i]);
                    element.disabled = false;
                    element.onchange = ()=>{
                        drawCtx.newScene = fossilizedIndex;
                        drawCtx.redraw();
                    };
                }

                const boundsCtrlSuffixs = ["bbox", "obbox"];
                for(let i=0; i<boundsCtrlSuffixs.length; ++i)
                {
                    const fossilized = i == 1;
                    const element = document.getElementById("boundsType-" + boundsCtrlSuffixs[i]);
                    element.disabled = false;
                    element.onchange = ()=>{
                        drawCtx.newUsingOBbox = fossilized;
                        drawCtx.redraw();
                    };
                }

                const filteringCtrlSuffixs = ["binary", "pcf"];
                for(let i=0; i<filteringCtrlSuffixs.length; ++i)
                {
                    const fossilized = i == 1;
                    const element = document.getElementById("filtering-" + filteringCtrlSuffixs[i]);
                    element.disabled = false;
                    element.onchange = ()=>{
                        drawCtx.usePCF = fossilized;
                        drawCtx.redraw();
                    };
                }

                const handleDragEvent = (event, touch)=>
                {
                    event.preventDefault();
                    const ref = touch
                                ? [event.touches[0].clientX, event.touches[0].clientY]
                                : [event.clientX, event.clientY]
                                ;
                    const bbox = drawCanvas.getBoundingClientRect();
                    const uv = [((ref[0] - bbox.x) / bbox.width),
                            (1.0 - (ref[1] - bbox.y) / bbox.height)];
                    const lightId = lightSelectCtrl.value;
                    drawCtx.lights[lightId].position = uv;
                    drawCtx.dirtyLights.push(lightId);
                    drawCtx.redraw();
                };

                const initDrag = event=>
                {
                   if(event.type == "mousedown")
                   {
                        const onMove = (event)=>{
                            handleDragEvent(event, false);
                        };
                        const onEnd = (event)=>{
                            event.preventDefault();
                            drawCanvas.removeEventListener("mousemove", onMove, false);
                            drawCanvas.removeEventListener("mouseup", onEnd, false);
                        };
                        drawCanvas.addEventListener("mousemove", onMove, false);
                        drawCanvas.addEventListener("mouseup", onEnd, false);
                        onMove(event);
                   }
                   else
                   {
                        const onMove = (event)=>{
                            handleDragEvent(event, true);
                        };
                        const onEnd = (event)=>{
                            event.preventDefault();
                            drawCanvas.removeEventListener("touchmove", onMove, false);
                            drawCanvas.removeEventListener("touchend", onEnd, false);
                        };
                        drawCanvas.addEventListener("touchmove", onMove, false);
                        drawCanvas.addEventListener("touchend", onEnd, false);
                        onMove(event);
                   }


                };
                drawCanvas.addEventListener("mousedown", initDrag, false);
                drawCanvas.addEventListener("touchstart", initDrag, false);


            });
        }
        else
        {
            drawCanvas.style.display = "none";
            document.getElementById("drawCanvasControls").style.display = "none";
            var notSupported = document.getElementById("notSupportedBrowser");
            notSupported.style.display = "block";
            notSupported.innerHTML = "WebGL2 not supported :(";
            return;
        }
    });


</script>

 
<hr id="footersep">
<div id="copyright">With the exception of third-party libraries / resources, code is public domain. Text &copy; Alister Chowdhury.</div>

<script>
async function _hsInit(...langs){
    for(const lang of langs)
    {
        let script = document.createElement("script");
        script.src = "/thirdparty/languages/" + lang +".min.js";
        script.async = true;
        script.onload = function(l){
            return function()
            {
                document.querySelectorAll("pre code.language-" + l)
                .forEach(hljs.highlightElement);
            };
        }
        (lang);
        document.body.appendChild(script);
    }
}
</script>
<script async src="/thirdparty/highlight.min.js" onload="_hsInit('c','glsl','python');">
</script></body>
</html>

