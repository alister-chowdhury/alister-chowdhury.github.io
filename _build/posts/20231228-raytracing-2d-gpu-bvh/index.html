<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=author content="Alister Chowdhury"><meta name=theme-color content=#2b2b2b><link href=/css.css rel=stylesheet><meta property=og:site_name content="Stuff And Also Things"><meta name=viewport content="width=device-width, initial-scale=1"><link rel=icon type=image/png sizes=32x32 href=/res/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/res/favicon-16x16.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-1WDZZ2C662"></script><script>if(window.dataLayer=window.dataLayer||[],"alister-chowdhury.github.io"==window.location.hostname){function a(){dataLayer.push(arguments)}a("js",new Date),a("config","G-1WDZZ2C662")}</script><link rel=canonical href=https://alister-chowdhury.github.io/posts/20231228-raytracing-2d-gpu-bvh/><meta property=og:title content="Raytracing In 2D, Using A GPU Generated BVH"><meta property=og:url content=https://alister-chowdhury.github.io/posts/20231228-raytracing-2d-gpu-bvh/><meta property=og:type content=article><meta property=og:description content="A method of 2D raytracing that is independant of the CPU, making use of WebGPU along the way."><meta property=og:image content=https://alister-chowdhury.github.io/posts/20231228-raytracing-2d-gpu-bvh/thumbnail.png><meta property=og:article:published_time content=2023-12-28T00:00:00><meta property=og:article:tag content=raytracing><meta property=og:article:tag content=webgpu><meta property=og:article:tag content=shadows><meta property=og:article:tag content=blocking><meta property=og:article:tag content=visibility><meta property=og:article:tag content=2D><meta property=og:article:tag content=rendering><meta property=og:article:tag content=graphics><script data-rh=true type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":[{"@type":"Person","name":"By Alister Chowdhury"}],"name":"Raytracing In 2D, Using A GPU Generated BVH","url":"https://alister-chowdhury.github.io/posts/20231228-raytracing-2d-gpu-bvh/","description":"A method of 2D raytracing that is independant of the CPU, making use of WebGPU along the way.","thumbnailUrl":"https://alister-chowdhury.github.io/posts/20231228-raytracing-2d-gpu-bvh/thumbnail.png","datePublished":"2023-12-28T00:00:00"}</script><title>Raytracing In 2D, Using A GPU Generated BVH</title><meta name=description content="A method of 2D raytracing that is independant of the CPU, making use of WebGPU along the way."><meta name=keywords content="raytracing, webgpu, shadows, blocking, visibility, 2D, rendering, graphics"><script>function addAfterLoaded(e){window.resourcesReady?e():window.afterLoaded.push(e)}window.resourcesReady=!1,window.afterLoaded=[];</script><script type=module>import{RTV2 as e}from"./rtrace_bvh_v2.js";window.bindRTV2Context=e.bindRTV2Context,window.resourcesReady=!0,window.afterLoaded.forEach(e=>{e()});</script><style>canvas{display:block;margin-left:auto;margin-right:auto}.imRef1>div>img{width:min(100%,256px);aspect-ratio:1/1}.sectionHeader{font-size:1.1em;font-weight:bold;text-align:center;padding-top:1em}</style><link rel=stylesheet href=/thirdparty/highlight.js.css></head><body> <div id=header> <a href=/>Home</a> <a href=/posts/>Posts</a> <a href=https://github.com/alister-chowdhury>Github</a> </div> <main> <h1>Raytracing In 2D, Using A GPU Generated BVH</h1> <h2>Background</h2> <p>Another month, another vaguely raytracing related post.</p> <p>If you've read some of the other stuff I've written about 2D raytracing (<a href=/posts/20230620-raytracing-in-2d/ target=_blank>Raytracing In 2D</a>, <a href=/posts/20231206-hybrid-df-rtrace-2d/ target=_blank>Hybrid Distance Field / Raytracing In 2D</a> etc), you may have noticed all of those require the acceleration structure to be generated on the CPU.</p> <p>While that's all very well and good for most use cases, it would be handy to be able to generate a BVH on the GPU itself (procedural or animating maps come to mind).</p> <h2>Building A BVH On The GPU</h2> <p>Originally, I attempted to do a similar thing to <a href=/posts/20230620-raytracing-in-2d/ target=_blank>Raytracing In 2D</a>, but on the GPU.</p> <p>Needless to say, the amount of passes required mixed with needing to perform a lot of <code>nth_element</code> seems rather impractical.</p> <p>Rather than starting at root node and working down, I attempt to flip this and start with buckets and work up towards the root node</p> <p>Basically, dice a grid by some power of 2 and bin lines by their center, building up a BVH by combining them.</p> <p>e.g:</p> <div class="imTable imRef1"> <div><img alt=bvh-ref src=res/bvh-ref.png><br>Input</div> <div><img alt=bvh-s0 src=res/bvh-s0.png><br>[4x4]</div> <div><img alt=bvh-s1 src=res/bvh-s1.png><br>[2x4] / [4x2]</div> <div><img alt=bvh-s2 src=res/bvh-s2.png><br>[2x2]</div> <div><img alt=bvh-s3 src=res/bvh-s3.png><br>[1x2] / [2x1]</div> </div> <p>With the node layout being:</p> <pre><code class=language-c>struct BvhNodeV2
{
    uint    leftType   : 1;     // 0 = node, 1 = line bucket
    uint    leftCount  : 31;    // always 0 for node
    uint    leftOffset;

    uint    rightType   : 1;    // 0 = node, 1 = line bucket
    uint    rightCount  : 31;   // always 0 for node
    uint    rightOffset;

    float4  leftBBox;
    float4  rightBBox;
};
</code></pre> <p>Happily fitting within three float4s.</p> <p>We can also determine the amount of memory required up front.</p> <pre><code>const uint bvhFloat4Size = 3;
uint numFloat4s = (gridSize * gridSize - 1) * bvhFloat4Size
                + numLines
                ;
</code></pre> <h3>Tiny Bucket Problem</h3> <p>One problem we may encounter is that we end up with a lot of tiny buckets, which cause needless overhead when traversing.</p> <p>Ideally we would &quot;merge&quot; line buckets when they are smaller than some threshold (say 16).</p> <p>Iterating buckets by their <a href=https://en.wikipedia.org/wiki/Z-order_curve target=_blank>Morton Encoding</a> order, means we can easily merge 4 nodes together, but additionally memory is spatially stored close by, increasing the likelihood of hitting a cache.</p> <div class="imTable imRef1"> <div><img alt=bvh-memory-addr src=res/bvh-memory-addr.png></div> </div> <h3>Putting It Together</h3> <p>We can generate the BVH in a single pass using a compute shader and shared memory (now possible to do in a browser with WebGPU).</p> <p>Here is a example of how that may look:</p> <details> <summary>Example BVH Gen Shader</summary> <pre><code class=language-c>#version 460 core
#extension GL_EXT_control_flow_attributes : require


/*
    level count : grid dims
              1 : 2x2
              2 : 4x4
              3 : 8x8
              4 : 16x16
*/
#ifndef NUM_LEVELS
#define NUM_LEVELS 3
#endif // NUM_LEVELS

#define GRID_SIZE_DIM (1&lt;&lt;NUM_LEVELS)

#ifndef ALLOW_MERGING
#define ALLOW_MERGING 1
#endif // ALLOW_MERGING

#define BVH_V2_METADATA_NODE            0
#define BVH_V2_METADATA_LINE_BUCKET     1
#define BVH_V2_NODE_FLOAT4_STRIDE       3

layout(local_size_x=GRID_SIZE_DIM, local_size_y=GRID_SIZE_DIM) in;

readonly  layout(std430, binding = 0) buffer inLines_   { vec4 inLines[]; };
writeonly layout(std430, binding = 1) buffer outBVH_    { vec4 outBVH[]; };
          layout(binding=2)           uniform numLines_ { uint numLines; };


// https://gist.github.com/JarkkoPFC/0e4e599320b0cc7ea92df45fb416d79a
uint encode16_morton2(uint x, uint y)
{
  uint res = x | (uint(y) &lt;&lt; 16);
  res = (res | (res&lt;&lt;4)) &amp; 0x0f0f0f0fu;
  res = (res | (res&lt;&lt;2)) &amp; 0x33333333u;
  res = (res | (res&lt;&lt;1)) &amp; 0x55555555u;
  return uint(res | (res&gt;&gt;15)) &amp; 0xffffu;
}


// When accessing shared memory, we use a linear index
// based upon the thread id, to prevent bank conflicts.
//
// When accessing the BVH memory, we use morton encoding
// to create better cache coherancy and to allow us to
// merge small line buckets togehter.
#define MAKE_LINEAR_ID(tid, brickSize)  ((tid).y * (brickSize) + (tid).x)
#define MAKE_MORTON_ID(tid)             (encode16_morton2((tid).x, (tid).y))


vec4 mergeBounds(vec4 a, vec4 b)
{
    return vec4(min(a.xy, b.xy), max(a.zw, b.zw));
}

float boundsArea(vec4 a)
{
    vec2 deriv = a.zw - a.xy;
    return max(0, deriv.x * deriv.y);
}


struct BVHNodeEntry
{
    uint type;
    uint offset;
    vec4 bbox;
    uint count;
};

BVHNodeEntry makeBottomLevelBVHEntry(uint offset, vec4 bbox, uint count)
{
    BVHNodeEntry result;
    result.type = BVH_V2_METADATA_LINE_BUCKET | (count &lt;&lt; 1);
    result.offset = offset;
    result.bbox = bbox;
    result.count = count;
    return result;
}


BVHNodeEntry writeBVHNode(uint outputOffset,
                          BVHNodeEntry left,
                          BVHNodeEntry right)
{
    outBVH[outputOffset] = uintBitsToFloat(uvec4(
        left.type, left.offset, right.type, right.offset
    ));
    outBVH[outputOffset + 1] = left.count == 0 ? vec4(0) : left.bbox;
    outBVH[outputOffset + 2] = right.count == 0 ? vec4(0) : right.bbox;

    // If we didn't do a proper merge, just return which
    // ever value was valid, or return an invalid value
    // if neither were valid. 
    if(right.count == 0)        { return left; }
    else if(left.count == 0)    { return right; }

    BVHNodeEntry merged;
    merged.type = BVH_V2_METADATA_NODE;
    merged.offset = outputOffset;
    merged.count = left.count + right.count;
    merged.bbox = mergeBounds(left.bbox, right.bbox);
    return merged;
}


BVHNodeEntry writeBVHLevel(uint outputOffset,
                           BVHNodeEntry A, BVHNodeEntry B,
                           BVHNodeEntry C, BVHNodeEntry D)
{

    bool done = false;
    BVHNodeEntry left;
    BVHNodeEntry right;

#if ALLOW_MERGING
    const uint maxLinesToMerge = 16u;

    uint mergedCount = A.count + B.count + C.count + D.count;
    bool hasSmallCount = mergedCount &lt;= maxLinesToMerge;
    bool allBuckets = all(equal(uvec4(A.type, B.type, C.type, D.type) &amp; 1u,
                                uvec4(BVH_V2_METADATA_LINE_BUCKET)));

    if(hasSmallCount &amp;&amp; allBuckets)
    {
        done = true;
        uint offset = A.offset;
        vec4 mergedBbox = mergeBounds(mergeBounds(A.bbox, B.bbox),
                                      mergeBounds(C.bbox, D.bbox));
        left = makeBottomLevelBVHEntry(offset, mergedBbox, mergedCount);
        right = makeBottomLevelBVHEntry(0, vec4(1.0, 1.0, -1.0, -1.0), 0);
    }

#endif // ALLOW_MERGING

    if(!done)
    {
        // Pick either [[A B] | [C D]]
        //          or [[A C] | [B D]]
        float ABarea = boundsArea(mergeBounds(A.bbox, B.bbox));
        float ACarea = boundsArea(mergeBounds(A.bbox, C.bbox));
        float CDarea = boundsArea(mergeBounds(C.bbox, D.bbox));
        float BDarea = boundsArea(mergeBounds(B.bbox, D.bbox));
        if((ABarea + CDarea) &gt; (ACarea + BDarea))
        {
            BVHNodeEntry tmp = B;
            B = C;
            C = tmp;
        }

        left = writeBVHNode(outputOffset + BVH_V2_NODE_FLOAT4_STRIDE,
                            A, B);
        right = writeBVHNode(outputOffset + BVH_V2_NODE_FLOAT4_STRIDE * 2,
                             C, D);
    }

    return writeBVHNode(outputOffset, left, right);
}


shared uint bucketAllocator[GRID_SIZE_DIM * GRID_SIZE_DIM];                     // 256 bytes
shared BVHNodeEntry nodeDataSwapA[GRID_SIZE_DIM * GRID_SIZE_DIM];               // 1792 or 2048 bytes
shared BVHNodeEntry nodeDataSwapB[(GRID_SIZE_DIM / 2) * (GRID_SIZE_DIM / 2)];   // 448 or 512 bytes


uint getNodeLevelOffset(uint level)
{
    // ((2^level)^2 - 1) nodes
    return ((1u &lt;&lt; (level + level)) - 1u)
            * BVH_V2_NODE_FLOAT4_STRIDE;
}


void fetchNodeDataLDS(uvec4 ids,
                      uint nodeDataSide,
                      out BVHNodeEntry A,
                      out BVHNodeEntry B,
                      out BVHNodeEntry C,
                      out BVHNodeEntry D)
{
    if((nodeDataSide &amp; 1u) == 0u)
    {
        A = nodeDataSwapA[ids.x];
        B = nodeDataSwapA[ids.y];
        C = nodeDataSwapA[ids.z];
        D = nodeDataSwapA[ids.w];
    }
    else
    {
        A = nodeDataSwapB[ids.x];
        B = nodeDataSwapB[ids.y];
        C = nodeDataSwapB[ids.z];
        D = nodeDataSwapB[ids.w];
    }
}


void buildNodeTree(uvec2 tid,
                   uint level,
                   uint nodeDataSide,
                   bool writeDebugData)
{
    uint inputBucketDim = (1u &lt;&lt; (level+1u));
    uint outputBucketDim = (1u &lt;&lt; level);

    if(all(lessThan(tid, uvec2(outputBucketDim))))
    {
        uint localBucketId = MAKE_LINEAR_ID(tid, outputBucketDim);
        uint Aid = MAKE_LINEAR_ID((tid * 2u + uvec2(0, 0)), inputBucketDim);
        uint Bid = MAKE_LINEAR_ID((tid * 2u + uvec2(1, 0)), inputBucketDim);
        uint Cid = MAKE_LINEAR_ID((tid * 2u + uvec2(0, 1)), inputBucketDim);
        uint Did = MAKE_LINEAR_ID((tid * 2u + uvec2(1, 1)), inputBucketDim);

        BVHNodeEntry A;
        BVHNodeEntry B;
        BVHNodeEntry C;
        BVHNodeEntry D;
        fetchNodeDataLDS(uvec4(Aid, Bid, Cid, Did),
                         nodeDataSide,
                         A, B, C, D);

        uint levelWriteStart = getNodeLevelOffset(level);
        uint nodeOffset = MAKE_MORTON_ID(tid);
        BVHNodeEntry bvhEntry = writeBVHLevel(levelWriteStart + 3u * BVH_V2_NODE_FLOAT4_STRIDE * nodeOffset,
                                              A, B, C, D);

        if(level != 0u)
        {
            if((nodeDataSide &amp; 1u) == 0u)
            {
                nodeDataSwapB[localBucketId] = bvhEntry;
            }
            else
            {
                nodeDataSwapA[localBucketId] = bvhEntry;
            }            
        }
    }

    if(level != 1u)
    {
        barrier();
    }
}


void main()
{
    uvec2 tid = gl_LocalInvocationID.xy;
    uint bucketId = MAKE_MORTON_ID(tid);

    // We bucket lines based upon where their center is.
    vec4 bucketBbox = vec4(tid, tid + 1u) /
                      vec2(GRID_SIZE_DIM, GRID_SIZE_DIM).xyxy;


    // This is the final bbox of the current cell, which starts
    // of as being invalid, but as we find relevant lines, we will
    // expand it to fit them all.
    vec4 finalBbox = vec4(1.0, 1.0, -1.0, -1.0);

    // Keep track of how many lines we need to home and the first and last
    // line id (to make it quicker to iterate over).
    uint bucketCount = 0u;
    uint firstLine = 0u;
    uint endLine = 0u;

    for(uint lineId = 0; lineId &lt; numLines; ++lineId)
    {
        vec4 line = inLines[lineId];
        vec2 center = (line.xy + line.zw) * 0.5;
        if(all(greaterThanEqual(center.xy, bucketBbox.xy))
           &amp;&amp; all(lessThan(center.xy, bucketBbox.zw)))
        {
            if(bucketCount == 0)
            {
                firstLine = lineId;
            }
            endLine = lineId + 1u;

            vec4 lineBbox = vec4(min(line.xy, line.zw), max(line.xy, line.zw));
            finalBbox = mergeBounds(finalBbox, lineBbox);

            ++bucketCount;
        }
    }

    bucketAllocator[bucketId] = bucketCount;
    barrier();

    // Write lines after the BVH data
    uint bucketWriteOffset = getNodeLevelOffset(NUM_LEVELS);
    for(uint id=0; id&lt;bucketId; ++id)
    {
        bucketWriteOffset += bucketAllocator[id];
    }

    uint ldsBucketId = MAKE_LINEAR_ID(tid, (1u &lt;&lt; NUM_LEVELS));
    nodeDataSwapA[ldsBucketId] = makeBottomLevelBVHEntry(bucketWriteOffset,
                                                         finalBbox,
                                                         bucketCount);


    barrier();

    // Write out lines into their respective places
    for(uint lineId = firstLine; lineId &lt; endLine; ++lineId)
    {
        vec4 line = inLines[lineId];
        vec2 center = (line.xy + line.zw) * 0.5;
        if(all(greaterThanEqual(center.xy, bucketBbox.xy))
           &amp;&amp; all(lessThan(center.xy, bucketBbox.zw)))
        {
            outBVH[bucketWriteOffset++] = vec4(line.xy, line.xy - line.zw);
        }
    }

    uint nodeDataSide = 0u;

    [[unroll]]
    for(int level=(NUM_LEVELS-1); level &gt;= 0; --level, ++nodeDataSide)
    {
        buildNodeTree(tid, uint(level), nodeDataSide);
    }
}
</code></pre> </details> <br> <br> The ray traversal is largely the same as previous stuff I've done (a stack based method), as such I'm not going to get into it here. <h2>Demo</h2> <p>As always, here's a demo, this one allows you to edit the lines, which is all handled on the GPU side (picking a vertex and updating the lines buffer).</p> <p>First time using <a href=https://www.w3.org/TR/webgpu/ target=_blank>WebGPU</a>, the API is sort of like a Vulkan-lite, or a primitive RHI abstraction (which I guess is what it kind of is) and is quite nice compared to WebGL (although still has teething issues).</p> <div> <div id=drawCanvasControls> <div class=sectionHeader>Global Controls</div> <div class=twoxnctrls> <div> <div id=resolutionCtrlDivLabel>Resolution</div> <div><input aria-labelledby=resolutionCtrlDivLabel id=resolutionCtrl disabled type=number min=1 max=2048 value=500 step=1><br></div> </div> <div> <div id=bvhLevelsDivLabel>BVH Levels</div> <div><input aria-labelledby=bvhLevelsDivLabel id=bvhLevels disabled type=range min=1 max=4 value=3 step=1><br></div> </div> <div> <div>Scene</div> <div class=knkRadio> <input disabled type=radio id=sceneType-simple name=sceneType><label for=sceneType-simple>Simple</label> <input disabled type=radio id=sceneType-moderate name=sceneType><label for=sceneType-moderate>Moderate</label> <input disabled type=radio id=sceneType-complex name=sceneType checked=checked><label for=sceneType-complex>Complex</label> <input disabled type=radio id=sceneType-veryComplex name=sceneType><label for=sceneType-veryComplex>Very Complex</label> </div> </div> </div> <div class=sectionHeader>Editing Controls</div> <div class=twoxnctrls> <div> <div id=editLinesLabel>Edit Lines</div> <div><input aria-labelledby=editLinesLabel id=editLinesCtrl disabled type=checkbox><br></div> </div> <div> <div id=snappingLabel>Snapping</div> <div><input aria-labelledby=snappingLabel id=snappingCtrl disabled type=checkbox checked><br></div> </div> <div> <div></div> <div><input aria-label=reset id=resetLinesCtrl value=Reset disabled type=button><br></div> </div> </div>  <p><canvas id=drawCanvas style=width:500px;height:500px width=500 height=500></canvas><br></p>  <div class=sectionHeader>Visualisation Controls</div> <div class=twoxnctrls> <div> <div>Vis Type</div> <div class=knkRadio> <input disabled type=radio id=visModeTypeCtrl-pointlight name=visModeTypeCtrl><label for=visModeTypeCtrl-pointlight>Pointlight</label> <input disabled type=radio id=visModeTypeCtrl-visibility checked=checked name=visModeTypeCtrl><label for=visModeTypeCtrl-visibility>Visibility</label> <input disabled type=radio id=visModeTypeCtrl-numNodeVisits name=visModeTypeCtrl><label for=visModeTypeCtrl-numNodeVisits>Num Node Visits</label> <input disabled type=radio id=visModeTypeCtrl-numIntersections name=visModeTypeCtrl><label for=visModeTypeCtrl-numIntersections>Num Intersections</label> <input disabled type=radio id=visModeTypeCtrl-composite name=visModeTypeCtrl><label for=visModeTypeCtrl-composite>Composite</label> <input disabled type=radio id=visModeTypeCtrl-bvh name=visModeTypeCtrl><label for=visModeTypeCtrl-bvh>BVH</label> </div> </div> <div> <div id=bvhStartLevelDivLabel>BVH Start</div> <div><input aria-labelledby=bvhStartLevelDivLabel id=bvhStartLevel disabled type=range min=0 max=7 value=0 step=1><br></div> </div> <div> <div id=bvhEndLevelDivLabel>BVH End</div> <div><input aria-labelledby=bvhEndLevelDivLabel id=bvhEndLevel disabled type=range min=0 max=7 value=5 step=1><br></div> </div> </div> </div> <div id=notSupportedBrowser></div> </div> <p>Here are all the relevant source code files:</p> <ul> <li>BVH Gen (GLSL): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/res/shaders/v2_tracing_generate_bvh.comp>v2_tracing_generate_bvh.comp</a></li> <li>Ray Traversal (GLSL): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/res/shaders/include/v2_tracing.glsli>v2_tracing.glsli</a></li> <li>Visualisers Ray (GLSL): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20231228-raytracing-2d-gpu-bvh/shaders/v2_tracing_test.frag>v2_tracing_test.frag</a></li> <li>Visualisers BVH (GLSL): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20231228-raytracing-2d-gpu-bvh/shaders/draw_tree.vert>draw_tree.vert</a> and <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20231228-raytracing-2d-gpu-bvh/shaders/draw_tree.frag>draw_tree.frag</a></li> <li>JS used for demo: <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20231228-raytracing-2d-gpu-bvh/rtrace_bvh_v2.js>rtrace_bvh_v2.js</a></li> </ul> </main> <script>{let e=Math.round(.6*Math.min(window.innerHeight||document.documentElement.clientHeight,window.innerWidth||document.documentElement.clientWidth)),t=document.getElementById("drawCanvas");t.style.width=e+"px",t.style.height=e+"px"}addAfterLoaded(()=>{let e=document.getElementById("drawCanvas"),t=window.bindRTV2Context(e);t.onready.then(()=>{{let n=document.getElementById("resolutionCtrl");n.disabled=!1;let l=l=>{let d=Math.min(n.max,Math.max(n.min,Math.round(n.value)));l&&n.value!=d&&(n.value=d),e.style.width=d+"px",e.style.height=e.style.width,t.redraw()};n.onchange=()=>{l(!0)},n.oninput=()=>{l(!1)}}{let d=document.getElementById("bvhLevels");d.disabled=!1;let i=()=>{t.setBVHLevel(1*d.value)};d.onchange=i,d.oninput=i}{let s=["simple","moderate","complex","veryComplex"],r=e=>()=>{t.setCurrentLines(e)};for(let o=0;o<s.length;++o){let a=document.getElementById(`sceneType-${s[o]}`);a.disabled=!1,a.onchange=r(o)}}{let g=document.getElementById("editLinesCtrl");g.disabled=!1,g.onchange=()=>{t.setEditing(g.checked)};let y=document.getElementById("snappingCtrl");y.disabled=!1,y.onchange=()=>{t.setSnapWhileEditing(y.checked)};let h=document.getElementById("resetLinesCtrl");h.disabled=!1,h.onclick=()=>{t.resetLines()}}{let m=["pointlight","visibility","numNodeVisits","numIntersections","composite"],c=e=>()=>{t.setDrawTree(!1),t.setCurrentTracingVisType(e)};for(let p=0;p<m.length;++p){let v=document.getElementById(`visModeTypeCtrl-${m[p]}`);v.disabled=!1,v.onchange=c(p)}{let u=document.getElementById("visModeTypeCtrl-bvh");u.disabled=!1,u.onchange=()=>{t.setDrawTree(!0)}}let b=document.getElementById("bvhStartLevel");b.disabled=!1;let E=()=>{t.setDrawTreeLevelStart(1*b.value)};b.onchange=E,b.oninput=E;let B=document.getElementById("bvhEndLevel");B.disabled=!1;let w=()=>{t.setDrawTreeLevel(1*B.value)};B.onchange=w,B.oninput=w}}),t.onerror.then(t=>{e.style.display="none",document.getElementById("drawCanvasControls").style.display="none";var n=document.getElementById("notSupportedBrowser");n.style.display="block",n.innerHTML=` Sorry, this demo won't work on your browser.<br> Reason: <strong>${t}</strong><br>`})});</script> <hr id=footersep> <div id=copyright>With the exception of third-party libraries / resources, code is public domain. Text &copy; Alister Chowdhury.</div> <script>async function _hsInit(...e){for(let n of e){let t=document.createElement("script");t.src="/thirdparty/languages/"+n+".min.js",t.async=!0,t.onload=function(e){return function(){document.querySelectorAll("pre code.language-"+e).forEach(hljs.highlightElement)}}(n),document.body.appendChild(t)}}</script> <script async src=/thirdparty/highlight.min.js onload="_hsInit('c');"></script></body></html>