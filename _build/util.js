class AsyncBarrier{constructor(){this.num=0,this.p=null,this.r=null}ready(){return 0==this.num}enqueue(e,r=null,t=null){let n=this;return null==n.p&&(n.p=new Promise(e=>{n.r=e})),++n.num,e.then(e=>{null!=r&&(n[r]=e),null!=t&&t.forEach(r=>{n[r]=e[r]}),0==--n.num&&n.r()}),n}async selfBarrier(){return await this.then(()=>{}),{...this}}async then(e){for(;0!=this.num;)await this.p;let r=e();return r}}export function createShader(e,r,t){if(!e)return null;let n=e.createShader(t);if(e.shaderSource(n,r,0),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS)){let a=e.getShaderInfoLog(n);var l=`Failed to compile shader (type: ${t}):
${a}.`;throw console.log(l),alert(l),Error(l)}return n}export function createGraphicsProgram(e,r,t=null){if(!e)return null;let n=e.createProgram();if(e.attachShader(n,r),null!=t&&e.attachShader(n,t),e.linkProgram(n),!e.getProgramParameter(n,e.LINK_STATUS)){let a=e.getProgramInfoLog(n);var l=`Failed to link graphics program:
${a}.`;throw console.log(l),alert(l),Error(l)}return e.detachShader(n,r),null!=t&&e.detachShader(n,t),n}export function getUniformLocation(e,r,t){return e?e.getUniformLocation(r,t):null}export function createDummyVAO(e){return e?e.createVertexArray():null}export function deleteShaders(e,...r){if(e)for(let t of r)t&&e.deleteShader(t)}export function isElementVisible(e){let r=e.getBoundingClientRect();return r.bottom>=0&&r.right>=0&&r.top<(window.innerHeight||document.documentElement.clientHeight)&&r.left<(window.innerWidth||document.documentElement.clientWidth)}export{AsyncBarrier};