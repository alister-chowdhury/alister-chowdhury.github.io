import{resolveChildren as e}from"./util.js";window.GPUBufferUsage||(window.GPUBufferUsage={}),window.GPUTextureUsage||(window.GPUTextureUsage={}),window.GPUShaderStage||(window.GPUShaderStage={});export const presentationFormat=navigator.gpu&&navigator.gpu.getPreferredCanvasFormat?navigator.gpu.getPreferredCanvasFormat():null;export const WebGPUState=(()=>{let e=null,t=null,r={ok:!1,err:null,device:null,adapter:null,onready:new Promise(t=>{e=t}),onerror:new Promise(e=>{t=e})},n=e=>{r.err=e,r.ok=!1,r.adapter=null,r.device=null,t(r)};return navigator.gpu?navigator.gpu.requestAdapter().then(t=>{if(!t){n("WebGPU adapter not found.");return}t.requestDevice().then(a=>{r.ok=!0,r.adapter=t,r.device=a,a.lost.then(()=>{n("WebGPU device lost!")}),r.ok&&e(r)})}):n("WebGPU not supported."),r})();export const createCmdBuffer=()=>{if(!WebGPUState.ok)return null;let e=WebGPUState.device,t=null,r=null,n=null,a=()=>t,u=()=>(t=e.createCommandEncoder(),r=null,n=a,t);n=u;let o=(...e)=>n().beginComputePass(...e),l=(...e)=>n().beginRenderPass(...e),c=(...e)=>n().clearBuffer(...e),p=(...e)=>n().copyBufferToBuffer(...e),s=(...e)=>n().copyBufferToTexture(...e),i=(...e)=>n().copyTextureToBuffer(...e),d=(...e)=>n().copyTextureToTexture(...e),P=(...e)=>n().insertDebugMarker(...e),f=(...e)=>n().popDebugGroup(...e),b=(...e)=>n().pushDebugGroup(...e),y=(...e)=>n().resolveQuerySet(...e),G=(...e)=>n().writeTimestamp(...e),m=()=>(null==r&&null!=t&&(n=u,r=t.finish(),t=null),r),U=(t=!0)=>{m(),r&&(e.queue.submit([r]),t&&(r=null))},S=(e,t)=>{let r=n(),a=r.beginComputePass(e);t(a),a.end()},g=(e,t)=>{let r=n(),a=r.beginRenderPass(e);t(a),a.end()},C=(t,r,n=0,a=0,u=null)=>{null==u&&(u=r.byteLength-a);let o=new Uint8Array(r.buffer,r.byteOffset+a,u),l=e.createBuffer({size:u,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint8Array(l.getMappedRange()).set(o),l.unmap(),p(l,0,t,n,u)},x={beginRenderPass:l,beginComputePass:o,clearBuffer:c,copyBufferToBuffer:p,copyBufferToTexture:s,copyTextureToBuffer:i,copyTextureToTexture:d,insertDebugMarker:P,popDebugGroup:f,pushDebugGroup:b,resolveQuerySet:y,writeTimestamp:G,finish:m,submit:U,computePass:S,renderPass:g,copyToGPUBuffer:C};return x};export const ImmContext=(()=>{let e=null,t={onready:new Promise(t=>{e=t})};return WebGPUState.onready.then(()=>{var r;Object.assign(t,createCmdBuffer()),t.submit=(r=t.submit,()=>r(!0)),e(t)}),t})();export const makeGPUBuffer=(e,t,r=0,n=null)=>{if(!WebGPUState.ok)return;null==n&&(n=t.byteLength-r);let a=new Uint8Array(t.buffer,t.byteOffset+r,n),u=WebGPUState.device.createBuffer({size:n,usage:e,mappedAtCreation:!0});return new Uint8Array(u.getMappedRange()).set(a),u.unmap(),u};export const createShaderModule=e=>WebGPUState.ok?WebGPUState.device.createShaderModule({code:e}):null;export const createBindGroupLayout=e=>{if(WebGPUState.ok){let t=WebGPUState.device.createBindGroupLayout(e);return t.createGroup=(...e)=>{let r=[];for(let n=0;n<e.length;++n)e[n]&&r.push({binding:n,resource:e[n].constructor==GPUBuffer?{buffer:e[n]}:e[n]});return WebGPUState.device.createBindGroup({layout:t,entries:r})},t}return null};export const createPipelineLayout=e=>WebGPUState.ok?WebGPUState.device.createPipelineLayout(e):null;export const createComputePipeline=e=>WebGPUState.ok?WebGPUState.device.createComputePipeline(e):null;export const createRenderPipeline=e=>WebGPUState.ok?WebGPUState.device.createRenderPipeline(e):null;export const createComputePipelineAsync=e=>WebGPUState.ok?WebGPUState.device.createComputePipelineAsync(e):null;export const createRenderPipelineAsync=e=>WebGPUState.ok?WebGPUState.device.createRenderPipelineAsync(e):null;export const asyncCompleteDesc=t=>WebGPUState.onready.then(()=>e(t));let makeSimpleAsyncCreateFunc=e=>t=>WebGPUState.onready.then(()=>e(t)),makeAsyncCreateFunc=e=>t=>asyncCompleteDesc(t).then(async t=>e(t));export const asyncMakeGPUBuffer=(e,t,r=0,n=null)=>Promise.all([t,WebGPUState.onready]).then(t=>makeGPUBuffer(e,t[0],r,n));export const asyncCreateShaderModule=e=>Promise.all([e,WebGPUState.onready]).then(e=>createShaderModule(e[0]));export const asyncCreateBindGroupLayout=makeSimpleAsyncCreateFunc(createBindGroupLayout);export const asyncCreatePipelineLayout=makeAsyncCreateFunc(createPipelineLayout);export const asyncCreateComputePipeline=makeAsyncCreateFunc(createComputePipelineAsync);export const asyncCreateRenderPipeline=makeAsyncCreateFunc(createRenderPipelineAsync);