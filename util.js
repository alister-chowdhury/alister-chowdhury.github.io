class AsyncBarrier{constructor(){this.num=0,this.p=null,this.r=null}ready(){return 0==this.num}enqueue(e,t=null,n=null){let r=this;return null==r.p&&(r.p=new Promise(e=>{r.r=e})),++r.num,e.then(e=>{null!=t&&(r[t]=e),null!=n&&n.forEach(t=>{r[t]=e[t]}),0==--r.num&&r.r()}),r}async selfBarrier(){return await this.then(()=>{}),{...this}}async then(e){for(;0!=this.num;)await this.p;let t=e(this);return t}}export function loadCommonShaderSource(e,t="webgl"){return fetch("/res/shaders/compiled_"+t+"/"+e).then(e=>e.text())}export function isElementVisible(e){let t=e.getBoundingClientRect();return t.bottom>=0&&t.right>=0&&t.top<(window.innerHeight||document.documentElement.clientHeight)&&t.left<(window.innerWidth||document.documentElement.clientWidth)}export const IS_LITTLE_ENDIAN=902392147==new DataView(new Uint32Array([902392147]).buffer).getUint32(0,!0);export const loadF32Lines=IS_LITTLE_ENDIAN?async e=>fetch(e).then(e=>e.blob().then(e=>e.arrayBuffer().then(e=>new Float32Array(e)))):async e=>fetch(e).then(e=>e.blob().then(e=>e.arrayBuffer().then(e=>{let t=Math.floor(e.byteLength/4),n=new DataView(e),r=new Float32Array(t);for(let i=0;i<t;++i)r[i]=n.getFloat32(4*i,!0);return r})));export const bitcast=(()=>{let e=new Uint32Array(1),t=new Float32Array(e.buffer),n=new Float32Array(e.buffer),r=(e,t,n)=>(t[0]=e,n[0]);return{f32:e=>r(e,n,n),u32:t=>r(t,e,e),i32:e=>r(e,t,t),f32tou32:t=>r(t,n,e),u32tof32:t=>r(t,e,n),f32toi32:e=>r(e,n,t),i32tof32:e=>r(e,t,n),u32toi32:n=>r(n,e,t),i32tou32:n=>r(n,t,e)}})();export const resolveChildren=e=>{let t=[],n=[],r=null;return(r=e=>{for(let[i,o]of Object.entries(e))"object"==typeof o&&(void 0!==o.then?(t.push(o),n.push([e,i])):r(o))})(e),Promise.all(t).then(t=>{for(let r=0;r<n.length;++r){let i=n[r];i[0][i[1]]=t[r]}return e})};export const createCanvasDragHandler=(e,t,n,r)=>{let i=(t,n)=>{t.preventDefault();let r=e.getBoundingClientRect(),i=n?[t.touches[0].clientX,t.touches[0].clientY]:[t.clientX,t.clientY];return[(i[0]-r.x)/r.width,1-(i[1]-r.y)/r.height]},o=o=>{if("mousedown"==o.type){let l=e=>{n(i(e,!1))},u=t=>{t.preventDefault(),e.removeEventListener("mousemove",l,!1),e.removeEventListener("mouseup",u,!1),r()};e.addEventListener("mousemove",l,!1),e.addEventListener("mouseup",u,!1),t(i(o,!1))}else{let s=e=>{n(i(e,!0))},h=t=>{t.preventDefault(),e.removeEventListener("touchmove",s,!1),e.removeEventListener("touchend",h,!1)};e.addEventListener("touchmove",s,!1),e.addEventListener("touchend",h,!1),s(o)}};e.addEventListener("mousedown",o,!1),e.addEventListener("touchstart",o,!1)};export const addDPIResizeWatcher=e=>{e.dpiWidth=e.width,e.dpiHeight=e.height,new ResizeObserver(e=>{let t=e[0],n,r;t.devicePixelContentBoxSize?(n=t.devicePixelContentBoxSize[0].inlineSize,r=t.devicePixelContentBoxSize[0].blockSize):t.contentBoxSize&&(n=Math.round(t.contentBoxSize[0].inlineSize*devicePixelRatio),r=Math.round(t.contentBoxSize[0].blockSize*devicePixelRatio));let i=t.target;i.dpiWidth=n,i.dpiHeight=r}).observe(e)};export{AsyncBarrier};