class AsyncBarrier{constructor(){this.num=0,this.p=null,this.r=null}ready(){return 0==this.num}enqueue(e,t=null,r=null){let n=this;return null==n.p&&(n.p=new Promise(e=>{n.r=e})),++n.num,e.then(e=>{null!=t&&(n[t]=e),null!=r&&r.forEach(t=>{n[t]=e[t]}),0==--n.num&&n.r()}),n}async selfBarrier(){return await this.then(()=>{}),{...this}}async then(e){for(;0!=this.num;)await this.p;let t=e();return t}}export function loadCommonShaderSource(e){return fetch("/res/shaders/compiled/"+e).then(e=>e.text())}export function createShader(e,t,r){if(!e)return null;let n=e.createShader(r);if(e.shaderSource(n,t,0),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS)){let o=e.getShaderInfoLog(n);var a=`Failed to compile shader (type: ${r}):
${o}.`;throw console.log(a),alert(a),Error(a)}return n}export function createGraphicsProgram(e,t,r=null){if(!e)return null;let n=e.createProgram();if(e.attachShader(n,t),null==r&&(void 0==e.dummyFragmentShader&&(e.dummyFragmentShader=createShader(e,"#version 300 es\nvoid main(){}",e.FRAGMENT_SHADER)),r=e.dummyFragmentShader),e.attachShader(n,r),e.linkProgram(n),!e.getProgramParameter(n,e.LINK_STATUS)){let o=e.getProgramInfoLog(n);var a=`Failed to link graphics program:
${o}.`;throw console.log(a),alert(a),Error(a)}return e.detachShader(n,t),e.detachShader(n,r),n}export function getUniformLocation(e,t,r){return e?e.getUniformLocation(t,r):null}export function createDummyVAO(e){return e?e.createVertexArray():null}export function deleteShaders(e,...t){if(e)for(let r of t)r&&e.deleteShader(r)}export function isElementVisible(e){let t=e.getBoundingClientRect();return t.bottom>=0&&t.right>=0&&t.top<(window.innerHeight||document.documentElement.clientHeight)&&t.left<(window.innerWidth||document.documentElement.clientWidth)}export const IS_LITTLE_ENDIAN=902392147==new DataView(new Uint32Array([902392147]).buffer).getUint32(0,!0);export const loadF32Lines=IS_LITTLE_ENDIAN?async e=>fetch(e).then(e=>e.blob().then(e=>e.arrayBuffer().then(e=>new Float32Array(e)))):async e=>fetch(e).then(e=>e.blob().then(e=>e.arrayBuffer().then(e=>{let t=Math.floor(e.byteLength/4),r=new DataView(e),n=new Float32Array(t);for(let o=0;o<t;++o)n[o]=r.getFloat32(4*o,!0);return n})));export const bitcast=(()=>{let e=new Uint32Array(1),t=new Float32Array(e.buffer),r=new Float32Array(e.buffer),n=(e,t,r)=>(t[0]=e,r[0]);return{f32:e=>n(e,r,r),u32:t=>n(t,e,e),i32:e=>n(e,t,t),f32tou32:t=>n(t,r,e),u32tof32:t=>n(t,e,r),f32toi32:e=>n(e,r,t),i32tof32:e=>n(e,t,r),u32toi32:r=>n(r,e,t),i32tou32:r=>n(r,t,e)}})();export{AsyncBarrier};