<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=author content="Alister Chowdhury"><meta name=theme-color content=#2b2b2b><link href=/css.css rel=stylesheet><meta property=og:site_name content="Stuff And Also Things"><meta name=viewport content="width=device-width, initial-scale=1"><link rel=icon type=image/png sizes=32x32 href=/res/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/res/favicon-16x16.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-1WDZZ2C662"></script><script>if(window.dataLayer=window.dataLayer||[],"alister-chowdhury.github.io"==window.location.hostname){function a(){dataLayer.push(arguments)}a("js",new Date),a("config","G-1WDZZ2C662")}</script><link rel=canonical href=https://alister-chowdhury.github.io/posts/20230620-raytracing-in-2d/><meta property=og:title content="Raytracing In 2D"><meta property=og:url content=https://alister-chowdhury.github.io/posts/20230620-raytracing-in-2d/><meta property=og:type content=article><meta property=og:description content="How to go about raytracing a 2D scene on the GPU, using purely vertex and fragment shaders."><meta property=og:image content=https://alister-chowdhury.github.io/posts/20230620-raytracing-in-2d/thumbnail.png><meta property=og:article:published_time content=2023-06-20T00:00:00><meta property=og:article:tag content=raytracing><meta property=og:article:tag content=BVH><meta property=og:article:tag content=2D><meta property=og:article:tag content=rendering><meta property=og:article:tag content=graphics><script data-rh=true type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":[{"@type":"Person","name":"By Alister Chowdhury"}],"name":"Raytracing In 2D","url":"https://alister-chowdhury.github.io/posts/20230620-raytracing-in-2d/","description":"How to go about raytracing a 2D scene on the GPU, using purely vertex and fragment shaders.","thumbnailUrl":"https://alister-chowdhury.github.io/posts/20230620-raytracing-in-2d/thumbnail.png","datePublished":"2023-06-20T00:00:00"}</script><title>Raytracing In 2D</title><meta name=description content="How to go about raytracing a 2D scene on the GPU, using purely vertex and fragment shaders."><meta name=keywords content="raytracing, BVH, 2D, rendering, graphics"><script>function addAfterBvh1ModuleLoaded(d){window.bvh1ModuleLoaded?d():window.afterBvh1ModuleLoaded.push(d)}function addAfterBvh1DataLoaded(d){window.bvh1DataLoaded?d():window.afterBvh1DataLoaded.push(d)}window.bvh1ModuleLoaded=!1,window.afterBvh1ModuleLoaded=[],window.bvh1DataLoaded=!1,window.afterBvh1DataLoaded=[];</script><script type=module>import{onResourcesLoaded as e,getDefaultLines as a,generateBVH as d,bindBvh1Context as o,onBvh1DataLoaded as t}from"./rtrace_bvh_v1.js";t(()=>{window.getDefaultLines=a,window.generateBVH=d,window.bvh1DataLoaded=!0,window.afterBvh1DataLoaded.forEach(e=>{e()})}),window.bindBvh1Context=o,window.bvh1ModuleLoaded=!0,window.afterBvh1ModuleLoaded.forEach(e=>{e()});</script><style>#bvhGenerationStepsContainer>div>img{width:238px;height:163px}#benchmarkGenBtnContainer{justify-content:center;align-content:center;text-align:center;margin-left:auto;margin-right:auto}#benchmarkGenBtn{padding-left:50px;padding-right:50px}#benchmarkGenCanvas{margin-top:5px;margin-bottom:5px}canvas{display:block;margin-left:auto;margin-right:auto}</style><link rel=stylesheet href=/thirdparty/highlight.js.css></head><body> <div id=header> <a href=/>Home</a> <a href=/posts/>Posts</a> <a href=https://github.com/alister-chowdhury>Github</a> </div> <div> <canvas id=drawCanvas style=width:500px;height:500px width=500 height=500></canvas><br> <div class="twoxnctrls mw40em" id=drawCanvasControls> <div> <div id=resolutionCtrlDivLabel>Resolution</div> <div><input aria-labelledby=resolutionCtrlDivLabel id=resolutionCtrl disabled type=number min=1 max=2048 value=500 step=1><br></div> </div> <div> <div id=numLinesSliderDivLabel>Number of lines to use</div> <div><input aria-labelledby=numLinesSliderDivLabel id=numLinesSlider disabled type=range min=0 max=1 value=1 step=1><br></div> </div> <div> <div id=enableWallClippingLabel>Walk through walls</div> <div><input aria-labelledby=enableWallClippingLabel id=enableWallClippingCtrl disabled type=checkbox checked><br></div> </div> <div> <div>BVH Overlay</div> <div class=knkRadio> <input disabled type=radio id=drawBvhCtrl-off name=drawBvhCtrl><label for=drawBvhCtrl-off>Off</label> <input disabled type=radio id=drawBvhCtrl-lines name=drawBvhCtrl checked=checked><label for=drawBvhCtrl-lines>Lines</label> <input disabled type=radio id=drawBvhCtrl-bboxes name=drawBvhCtrl><label for=drawBvhCtrl-bboxes>BBoxes</label> <input disabled type=radio id=drawBvhCtrl-all name=drawBvhCtrl><label for=drawBvhCtrl-all>All</label> </div> </div> <div> <div>Ray Vis Type</div> <div class=knkRadio> <input disabled type=radio id=rayVisTypeCtrl-pointlight name=rayVisTypeCtrl checked=checked><label for=rayVisTypeCtrl-pointlight>Pointlight</label> <input disabled type=radio id=rayVisTypeCtrl-visibility name=rayVisTypeCtrl><label for=rayVisTypeCtrl-visibility>Visibility</label> <input disabled type=radio id=rayVisTypeCtrl-numIntersections name=rayVisTypeCtrl><label for=rayVisTypeCtrl-numIntersections>Num Intersections</label> <input disabled type=radio id=rayVisTypeCtrl-numVisits name=rayVisTypeCtrl><label for=rayVisTypeCtrl-numVisits>Num Node Visits</label> <input disabled type=radio id=rayVisTypeCtrl-composite name=rayVisTypeCtrl><label for=rayVisTypeCtrl-composite>Composite</label> <input disabled type=radio id=rayVisTypeCtrl-lineId name=rayVisTypeCtrl><label for=rayVisTypeCtrl-lineId>Line ID</label> </div> </div> </div> <div id=notSupportedBrowser></div> </div> <br> <main> <h1>Raytracing In 2D</h1> <div class=toc> <ul> <li><a href=#background>Background</a></li> <li><a href=#building-the-bvh>Building The BVH</a></li> <li><a href=#shader-traversal>Shader Traversal</a></li> <li><a href=#demo>Demo</a></li> </ul> </div> <h2 id=background>Background</h2> <p>During Covid times, me and a group of friends got very into using <a target=_blank href=https://www.dnd-compendium.com/dm-resources/virtual-tabletops>virtual tabletops</a>, and while playing them, a certain friend who was DMing really wanted to boost the graphics quality, which scaled pretty horribly, especially on older hardware.</p> <p>One of the biggest bottlenecks seemed to be around how many blockers they would put in their scene, around 10-20 seemed to be ok, but when they started getting into full level designer mode and adding like 200+ it would be basically unplayable.</p> <p>I can't say I'm sure exactly how this particular VTT implemented this, but I assume it involved a linear loop, line intersecting against every blocker, which in the world of raytracing is a big no-no.</p> <p>For the specific case of vision blocking, raytracing doesn't seem like something you'd want to do full-frame, every frame and I actually already have a solution which involves <a href=https://alister-chowdhury.github.io/posts/20230628-project-and-stencil/>projecting and incrementing a stencil buffer</a> (in a similar sort of vibe to <a target=_blank href=https://en.wikipedia.org/wiki/Shadow_volume>shadow volumes</a>), which seemed to work rather nicely and I may post about at some point.</p> <p>And likewise for lights, using a circular shadow map, offline polygon generation or simply baking lighting data seems like a more reasonable approach (also may cover some implementations for those I've been playing with).</p> <p>Regardless, I thought it would be interesting to implement raytracing on the GPU (targeting web browsers and not assuming good hardware) from scratch.</p> <p>(The same logic can be used to perform traces on the CPU as well, which probably has a more direct use of preventing people from clipping through walls)</p> <h2 id=building-the-bvh>Building The BVH</h2> <p>Arguably the most important part about accelerating raytracing is the <a target=_blank href=https://en.wikipedia.org/wiki/Bounding_volume_hierarchy>BVH</a>, how this is structured will basically define how you go about discarding batches of lines from being processed any further.</p> <p>I settled on using a b-tree based approach, where each node is made of 48 bytes (3 x float4) stored in a linear buffer and has the following layout:</p> <pre><code class=language-c>struct BvhNodeV1
{
    uint    leftType;
    uint    leftId;

    uint    rightType;
    uint    rightId;

    float4  leftData;
    float4  rightData;
};
</code></pre> <p>Where:</p> <ul> <li><code>type</code> is 0 if it's a <strong>node</strong> or 1 if it's a <strong>line</strong>.</li> <li><code>id</code> is buffer index of a <strong>node</strong> or <code>lineId</code> of a <strong>line</strong>.</li> <li><code>data</code> is the bbox of the <strong>node</strong> or line parameters of a <strong>line</strong>.</li> </ul> <p>You may think using an entire 128bits for both the types and ids may seem wasteful (do we really need 16 bytes for two bools and two offsets). And you would be right, however by aligning the result into a float4, it means actually fetching the data is reasonably GPU friendly.</p> <pre><code class=language-glsl>uniform sampler1D bvh;
...
vec4 v0 = texelFetch(bvh, offset);          // types and ids (asuint / floatBitsToInt)
vec4 v1 = texelFetch(bvh, offset + 1);      // left data
vec4 v2 = texelFetch(bvh, offset + 2);      // right data
</code></pre> <p>To construct the BVH we repeatedly subdivide the number of lines in half, this is done by:</p> <ul> <li>Calculating the box that contains the <strong>center</strong> point of each line.</li> <li><a target=_blank href=https://en.cppreference.com/w/cpp/algorithm/nth_element>Partial sorting</a> <code>centerX</code> or <code>centerY</code> depending on which axis was longer in the previously calculated box, using [size/2] as the mid point.</li> <li>Partitioning the left to be <code>[0, size/2)</code> and right to be <code>[size/2, size)</code>.</li> </ul> <div id=bvhGenerationStepsContainer class=imTable> <div><img alt=lines0 src=res/lines0.png><br>Input Lines</div> <div><img alt=lines1 src=res/lines1.png><br>First Level</div> <div><img alt=lines2 src=res/lines2.png><br>Second Level</div> </div> <p>The BVH generation code was written in C++ (link to source at the bottom) and even when targeting WASM, should be rather quick, you can run a little benchmark here (<code>n log(n)</code> time):</p> <div id=benchmarkGenBtnContainer> <input type=button id=benchmarkGenBtn disabled value=Run> <canvas id=benchmarkGenCanvas style=display:none></canvas> <div id=benchmarkGenInfo style=display:none></div> </div> <p>So much so, an interesting idea would be to offline calculate a BVH for static elements and per frame generate another BVH for dynamic elements and simply merge their root nodes together (perhaps for another time).</p> <h2 id=shader-traversal>Shader Traversal</h2> <p>To get around the problem of not having arbitrary recursion in shaders, a stack based approach is used instead, as a (very) simplified pseudo-code (python) outline:</p> <pre><code class=language-python>def find_closest_hit(ro, rd):
    closest_hit = float(&quot;inf&quot;)

    stack_offsets = fixed_size_array(MAX_STACK_SIZE)
    stack_offsets.push(0) # Root node

    while stack_offsets:
        offset = stack_offsets.pop()
        node_data = fetch_bvh_data(offset)

        left, right = split_left_right(node_data)
        to_add = []
        
        for side in (left, right):
            if side.is_line():
                hit_dist = ray_intersection_dist(ro, rd, side.data)
                if hit_dist &lt; closest_hit:
                    closest_hit = hit_dist

            else:
                hit_dist = ray_intersction_bbox_dist(ro, rd, side.data):
                
                # Only push the node for evaluation if it may result in
                # a closer intersection
                if hit_dist &lt; closest_hit:
                    to_add_entry = {&quot;dist&quot;: hit_dist, &quot;offset&quot;: data.idx}
                    # and keep the closest local intersection at the back,
                    # so it's evaluated first.
                    if to_add.empty() or to_add[0][&quot;dist&quot;] &gt; hist_dist:
                        to_add.append(to_add_entry)
                    else:
                        to_add.insert(0, to_add_entry)

        for to_add_entry in to_add:
            stack_offsets.push(to_add_entry[&quot;offset&quot;])

    return closest_hit
</code></pre> <h2 id=demo>Demo</h2> <p>For reference, on an Intel UHD Graphics 630, it takes ~9ms to do a full 1920x1080 pass, so not something you'd want to use directly for lighting.</p> <p>Worth noting, that it's incredibly simple to generate a distance field from a BVH (<code>findNearestDistanceBvhV1</code>), switching to a SDF model can reduce a full frame evaluation down from 9ms to 3ms at the cost.</p> <p>Here are all the relevant source code files:</p> <ul> <li>BVH generation (C++): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/res/bvh_v1/generate_bvh_v1.cpp>generate_bvh_v1.cpp</a></li> <li>Ray traversal (C++): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/res/bvh_v1/trace_bvh_v1.cpp>trace_bvh_v1.cpp</a></li> <li>Ray traversal (GLSL): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/res/shaders/include/v1_tracing.glsli>v1_tracing.glsli</a></li> <li>Visualisers (GLSL): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230620-raytracing-in-2d/shaders/v1_tracing_test.frag>v1_tracing_test.frag</a></li> <li>Line / BBOX overlays (GLSL): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230620-raytracing-in-2d/shaders/v1_draw_bvh.vert>v1_draw_bvh.vert</a></li> <li>JS used for demo: <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230620-raytracing-in-2d/rtrace_bvh_v1.js>rtrace_bvh_v1.js</a></li> <li>WASM binary: <a target=_blank href=/res/bvh_v1.wasm>bvh_v1.wasm</a></li> </ul> <hr> <p>Slighly off tangent, but I ended up putting together a subset of the <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/tree/master/_source/ministl>C std and C++ stl</a> while making this.</p> </main> <script>{let e=Math.round(.6*Math.min(window.innerHeight||document.documentElement.clientHeight,window.innerWidth||document.documentElement.clientWidth)),t=document.getElementById("resolutionCtrl");e=Math.min(t.max,Math.max(t.min,Math.round(e))),t.value=e;let l=document.getElementById("drawCanvas");l.style.width=e+"px",l.style.height=e+"px"}addAfterBvh1ModuleLoaded(()=>{let e=document.getElementById("drawCanvas"),t=window.bindBvh1Context(e);if(t.valid)t.resourceLoaded.then(()=>{let l=document.getElementById("numLinesSlider"),n=document.getElementById("resolutionCtrl"),i=document.getElementById("enableWallClippingCtrl"),a=window.getDefaultLines();l.max=a.length/4,l.value=l.max,l.disabled=!1;let r=()=>{t.updateGpuBvhTexture(a.slice(0,4*l.value)),t.redraw()};l.oninput=r,l.onchange=r,n.disabled=!1;let d=()=>{let l=Math.min(n.max,Math.max(n.min,Math.round(n.value)));n.value!=l&&(n.value=l),e.style.width=l+"px",e.style.height=e.style.width,t.redraw()};n.onchange=d,i.disabled=!1,i.onchange=()=>{t.allowWallClipping=i.checked};let o=["off","lines","bboxes","all"];for(let s=0;s<o.length;++s){let h=s,m=document.getElementById("drawBvhCtrl-"+o[s]);m.disabled=!1,m.onchange=()=>{t.drawBvhOverlayMode=h,t.redraw()}}let g=["pointlight","visibility","numIntersections","numVisits","composite","lineId"];for(let y=0;y<g.length;++y){let c=y,u=document.getElementById("rayVisTypeCtrl-"+g[y]);u.disabled=!1,u.onchange=()=>{t.rayVisMode=c,t.redraw()}}});else{e.style.display="none",document.getElementById("drawCanvasControls").style.display="none";var l=document.getElementById("notSupportedBrowser");l.style.display="block",l.innerHTML=` Sorry, this demo won't work on your browser.<br> Reason: <strong>WebGL2 not supported :(</strong><br>`;return}}),addAfterBvh1DataLoaded(()=>{let e=window.getDefaultLines(),t=e.length/4,l=window.generateBVH,n=document.getElementById("benchmarkGenBtn"),i=document.getElementById("benchmarkGenCanvas"),a=document.getElementById("benchmarkGenInfo");n.onclick=()=>{let n=Array(t);n[0]=0;for(let r=1;r<t;++r){let d=e.slice(0,4*r);for(let o=0;o<5;++o)l(d);let s=performance.now();for(let h=0;h<100;++h)l(d);let m=performance.now();n[r]=(m-s)/100}let g=Math.min(...n),y=Math.max(...n),c=1/(y-g);i.style.display="block",i.width=t,i.height=t;let u=i.getContext("2d"),$=i.height;u.setTransform(1,0,0,-$*c,-g,$),u.clearRect(0,0,i.width,y),u.rect(0,0,i.width,y),u.fillStyle="#400778",u.fill();let b=i.width/(n.length-1);u.strokeStyle="#00d5ff";for(let w=0;w<n.length;++w){let p=b*w,B=n[w];u.beginPath(),u.moveTo(p,0),u.lineTo(p,B),u.stroke()}a.style.display="block",a.innerHTML=`Max lines: ${t}<br>Max time: ${y}ms`},n.disabled=!1});</script> <hr id=footersep> <div id=copyright>With the exception of third-party libraries / resources, code is public domain. Text &copy; Alister Chowdhury.</div> <script>async function _hsInit(...e){for(let n of e){let t=document.createElement("script");t.src="/thirdparty/languages/"+n+".min.js",t.async=!0,t.onload=function(e){return function(){document.querySelectorAll("pre code.language-"+e).forEach(hljs.highlightElement)}}(n),document.body.appendChild(t)}}</script> <script async src=/thirdparty/highlight.min.js onload="_hsInit('c','glsl','python');"></script></body></html>