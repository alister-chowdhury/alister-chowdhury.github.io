<!DOCTYPE html><html lang=en><head><meta property=og:title content="Raytracing In 2D"><meta property=og:url content=https://alister-chowdhury.github.io/posts/20230620-raytracing-in-2d/><meta property=og:type content=article><meta property=og:description content="How to go about raytracing a 2D scene on the GPU, using purely vertex and fragment shaders."><meta property=og:article:published_time content=2023-06-20T00:00:00><meta property=og:article:tag content=raytracing><meta property=og:article:tag content=2D><meta property=og:article:tag content=rendering><meta property=og:article:tag content=graphics><meta charset=utf-8><meta name=author content="Alister Chowdhury"><meta name=theme-color content=#2b2b2b><link href=/css.css rel=stylesheet><meta property=og:site_name content="Stuff And Also Things"><meta name=viewport content="width=device-width, initial-scale=1"><title>Raytracing In 2D</title><meta name=description content="How to go about raytracing a 2D scene on the GPU, using purely vertex and fragment shaders."><meta name=keywords content="raytracing, 2D, rendering, graphics"><script>function addAfterBvh1ModuleLoaded(d){window.bvh1ModuleLoaded?d():window.afterBvh1ModuleLoaded.push(d)}function addAfterBvh1DataLoaded(d){window.bvh1DataLoaded?d():window.afterBvh1DataLoaded.push(d)}window.bvh1ModuleLoaded=!1,window.afterBvh1ModuleLoaded=[],window.bvh1DataLoaded=!1,window.afterBvh1DataLoaded=[];</script><script type=module>import{onResourcesLoaded as e,getDefaultLines as a,generateBVH as d,bindBvh1Context as o,onBvh1DataLoaded as t}from"./rtrace_bvh_v1.js";t(()=>{window.getDefaultLines=a,window.generateBVH=d,window.bvh1DataLoaded=!0,window.afterBvh1DataLoaded.forEach(e=>{e()})}),window.bindBvh1Context=o,window.bvh1ModuleLoaded=!0,window.afterBvh1ModuleLoaded.forEach(e=>{e()});</script><style>#drawCanvasControls{width:fit-content;margin-left:auto;margin-right:auto;padding:1em}#drawCanvasControls>div{display:grid;grid-auto-flow:column;grid-auto-columns:1fr 2fr;border:#7373c3 1px solid;border-top:0}#drawCanvasControls>div:first-of-type{border-top:#7373c3 1px solid}#drawCanvasControls>div>div{text-align:center;padding-left:.5em;padding-right:.5em;margin-top:auto;margin-bottom:auto}#drawCanvasControls>div>div:last-of-type{border-left:#7373c3 1px solid;height:100%}.knuckleRadio input[type="radio"]{display:none}.knuckleRadio input[type="radio"]+label,input[type="button"]{background-color:#1f1f1f;cursor:pointer;border:#7373c3 2px outset;padding:5px;display:inline-block;margin-top:5px;margin-bottom:5px;color:#d3d3d3;font-family:monospace}.knuckleRadio input[type="radio"]:checked+label,input[type="button"]:active{color:#00d5ff;background-color:#400778;cursor:pointer;border:#7373c3 2px inset;padding:5px;display:inline-block;margin-top:5px;margin-bottom:5px;font-family:monospace}canvas{display:block;margin-left:auto;margin-right:auto}</style><link rel=stylesheet href=/thirdparty/highlight.js.css></head><body> <div id=header> <a href=/>Home</a> <a href=/posts/>Posts</a> <a href=https://github.com/alister-chowdhury>Github</a> </div> <main> <h1>Raytracing In 2D</h1> <h2>Background</h2> <p>During Covid times, me and a group of friends got very into using <a target=_blank href=https://www.dnd-compendium.com/dm-resources/virtual-tabletops>virtual tabletops</a>, and while playing them, a certain friend who was DMing really wanted to boost the graphics quality, which scaled pretty horribly, especially on older hardware.</p> <p>One of the biggest bottlenecks seemed to be around how many blockers they would put in their scene, around 10-20 seemed to be ok, but when they started getting into full level designer mode and adding like 200+ it would be basically unplayable.</p> <p>I can't say I'm sure exactly how this particular VTT implemented this, but I assume it involved a linear loop, line intersecting against every blocker, which in the world of raytracing is a big no-no.</p> <p>For the specific case of vision blocking, raytracing doesn't seem like something you'd want to do full-frame, every frame and I actually already have a solution which involves projecting and incrementing a stencil buffer (in a similar sort of vibe to <a target=_blank href=https://en.wikipedia.org/wiki/Shadow_volume>shadow volumes</a>), which seemed to work rather nicely and I may post about at some point.</p> <p>And likewise for lights, using a circular shadowmap, offline polygon generation or simply baking lighting data seems like a more reasonable approach (also may cover some implementations for those I've been playing with).</p> <p>Regardless, I thought it would be interesting to implement raytracing on the GPU (targeting web broswers and not assuming good hardware) from scratch.</p> <h2>Building The BVH</h2> <p>Arguably the most important part about accelerating raytracing is the <a target=_blank href=https://en.wikipedia.org/wiki/Bounding_volume_hierarchy>BVH</a>, how this is structured will basically define how you go about discarding batches of lines from being processed any further.</p> <p>I settled on using a b-tree based approach, where each node is made of 48 bytes (3 x float4) is stored in a linear buffer and has the following layout:</p> <pre><code class=language-c>struct BvhNodeV1
{
    uint    leftType;
    uint    leftId;

    uint    rightType;
    uint    rightId;

    float4  leftData;
    float4  rightData;
};
</code></pre> <p>Where:</p> <ul> <li><code>type</code> is 0 if it's a <strong>node</strong> or 1 if it's a <strong>line</strong>.</li> <li><code>id</code> is buffer index of a <strong>node</strong> or <code>lineId</code> of a <strong>line</strong>.</li> <li><code>data</code> is the bbox of the <strong>node</strong> or line parameters of a <strong>line</strong>.</li> </ul> <p>You may think using an entire 128bits for both the types and ids may seem wasteful (do we really need 16 bytes for two bools and a two offsets). And you would be right, however by aligning the result into a float4, it means actually fetching the data is reasonably GPU friendly.</p> <pre><code class=language-glsl>uniform sampler1D bvh;
...
vec4 v0 = texelFetch(bvh, offset);          // types and ids (asuint / floatBitsToInt)
vec4 v1 = texelFetch(bvh, offset + 1);      // left data
vec4 v2 = texelFetch(bvh, offset + 2);      // right data
</code></pre> <p>The BVH generation code was written in C++ (source at the bottom) and even when targetting WASM, should be rather quick, you can run a little benchmark here (should be linear time):</p> <input type=button id=benchmarkGenBtn disabled value=Run> <canvas id=benchmarkGenCanvas style=display:none></canvas> <div id=benchmarkGenInfo style=display:none></div> <p>So much so, an interesting idea would be to offline calculate a BVH for static elements and per frame generate another BVH for dynamic elements and simply merge their root nodes together (perhaps for another time).</p> <h2>Shader Traversal</h2> <p>To get around the problem of not having arbitary recursion in shaders, a stack based approach is used instead, as a (very) simplified psuedo-code (python) outline:</p> <pre><code class=language-python>def find_closest_hit(ro, rd):
    closest_hit = float(&quot;inf&quot;)

    stack_offsets = fixed_size_array(MAX_STACK_SIZE)
    stack_offsets.append(0) # Root node

    while(!stack_offsets.empty()):
        offset = stack_offsets.pop()
        node_data = fetch_bvh_data(offset)

        left, right = split_left_right(node_data)
        to_add = []

        for side in (left, right):
            if side.is_line():
                hit_dist = ray_intersection_dist(ro, rd, side.data)
                if hit_dist &lt; closest_hit:
                    closest_hit = hit_dist

            else:
                hit_dist = ray_intersction_bbox_dist(ro, rd, side.data):

                # Only push the node for evaluation if it may result in
                # a closer intersection
                if hit_dist &lt; closest_hit:
                    to_add_entry = {&quot;dist&quot;: hit_dist, &quot;offset&quot;: data.idx}
                    # and keep the closest local intersection at the back,
                    # so it's evaluated first.
                    if to_add.empty() or to_add[0][&quot;dist&quot;] &gt; hist_dist:
                        to_add.append(to_add_entry)
                    else:
                        to_add.insert(0, to_add_entry)

        for to_add_entry in to_add:
            stack_offsets.push(to_add_entry[&quot;offset&quot;])

    return closest_hit
</code></pre> <p>And here is a little demo of it in action, for reference, on a Intel UHD Graphics 630, it takes ~9ms to do a full 1920x1080 pass, so not something you'd want to use directly for lighting.</p> <div> <canvas id=drawCanvas style=width:500px;height:500px width=500 height=500></canvas><br> <div id=drawCanvasControls> <div> <div id=resolutionCtrlDivLabel>Resolution</div> <div><input input aria-labelledby=resolutionCtrlDivLabel id=resolutionCtrl disabled type=number min=1 max=2048 value=500 step=1 style=display:table-cell;width:100%><br></div> </div> <div> <div id=numLinesSliderDivLabel>Number of lines to use</div> <div><input aria-labelledby=numLinesSliderDivLabel id=numLinesSlider disabled type=range min=0 max=1 value=1 step=1 style=display:table-cell;width:100%><br></div> </div> <div> <div>BVH Overlay</div> <div class=knuckleRadio> <input disabled type=radio id=drawBvhCtrl-off name=drawBvhCtrl><label for=drawBvhCtrl-off>Off</label> <input disabled type=radio id=drawBvhCtrl-lines name=drawBvhCtrl checked=checked><label for=drawBvhCtrl-lines>Lines</label> <input disabled type=radio id=drawBvhCtrl-bboxes name=drawBvhCtrl><label for=drawBvhCtrl-bboxes>BBoxes</label> <input disabled type=radio id=drawBvhCtrl-all name=drawBvhCtrl><label for=drawBvhCtrl-all>All</label> </div> </div> <div> <div>Ray Vis Type</div> <div class=knuckleRadio> <input disabled type=radio id=rayVisTypeCtrl-pointlight name=rayVisTypeCtrl checked=checked><label for=rayVisTypeCtrl-pointlight>Pointlight</label> <input disabled type=radio id=rayVisTypeCtrl-visibility name=rayVisTypeCtrl><label for=rayVisTypeCtrl-visibility>Visibility</label> <input disabled type=radio id=rayVisTypeCtrl-numIntersections name=rayVisTypeCtrl><label for=rayVisTypeCtrl-numIntersections>Num Intersections</label> <input disabled type=radio id=rayVisTypeCtrl-numVisits name=rayVisTypeCtrl><label for=rayVisTypeCtrl-numVisits>Num Node Visits</label> <input disabled type=radio id=rayVisTypeCtrl-composite name=rayVisTypeCtrl><label for=rayVisTypeCtrl-composite>Composite</label> <input disabled type=radio id=rayVisTypeCtrl-lineId name=rayVisTypeCtrl><label for=rayVisTypeCtrl-lineId>Line ID</label> </div> </div> </div> <div id=notSupportedBrowser></div> </div> <p>Worth nothing, that it's incredibly simple to generate a distance field from a BVH (<code>findNearestDistanceBvhV1</code>), switching to a SDF model can reduce a full frame evaluation down from 9ms to 3ms at the cost.</p> <p>Here are all the relevant source code files:</p> <ul> <li>BVH generation (C++): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230620-raytracing-in-2d/bvh_v1/generate_bvh_v1.cpp>generate_bvh_v1.cpp</a></li> <li>Ray traversal (GLSL): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230620-raytracing-in-2d/shaders/v1_tracing.glsli>v1_tracing.glsli</a></li> <li>Visualisers (GLSL): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230620-raytracing-in-2d/shaders/v1_tracing_test.frag>v1_tracing_test.frag</a></li> <li>Line / BBOX overlays (GLSL): <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230620-raytracing-in-2d/shaders/v1_draw_bvh.vert>v1_draw_bvh.vert</a></li> </ul> </main> <script>{let e=Math.round(.6*Math.min(window.innerHeight||document.documentElement.clientHeight,window.innerWidth||document.documentElement.clientWidth)),t=document.getElementById("resolutionCtrl");e=Math.min(t.max,Math.max(t.min,Math.round(e))),t.value=e;let l=document.getElementById("drawCanvas");l.style.width=e+"px",l.style.height=e+"px"}addAfterBvh1ModuleLoaded(()=>{let e=document.getElementById("drawCanvas"),t=window.bindBvh1Context(e);if(t.valid)t.resourceLoaded.then(()=>{let l=document.getElementById("numLinesSlider"),n=document.getElementById("resolutionCtrl"),i=window.getDefaultLines();l.max=i.length/4,l.value=l.max,l.disabled=!1;let a=()=>{t.updateGpuBvhTexture(i.slice(0,4*l.value)),t.redraw()};l.oninput=a,l.onchange=a,n.disabled=!1;let d=()=>{let l=Math.min(n.max,Math.max(n.min,Math.round(n.value)));n.value!=l&&(n.value=l),e.style.width=l+"px",e.style.height=e.style.width,t.redraw()};n.onchange=d;let r=["off","lines","bboxes","all"];for(let o=0;o<r.length;++o){let s=o,m=document.getElementById("drawBvhCtrl-"+r[o]);m.disabled=!1,m.onchange=()=>{t.drawBvhOverlayMode=s,t.redraw()}}let h=["pointlight","visibility","numIntersections","numVisits","composite","lineId"];for(let g=0;g<h.length;++g){let y=g,u=document.getElementById("rayVisTypeCtrl-"+h[g]);u.disabled=!1,u.onchange=()=>{t.rayVisMode=y,t.redraw()}}});else{e.style.display="none",document.getElementById("drawCanvasControls").style.display="none";var l=document.getElementById("notSupportedBrowser");l.style.display="block",l.innerHTML="WebGL2 not supported :(";return}}),addAfterBvh1DataLoaded(()=>{let e=window.getDefaultLines(),t=e.length/4,l=window.generateBVH,n=document.getElementById("benchmarkGenBtn"),i=document.getElementById("benchmarkGenCanvas"),a=document.getElementById("benchmarkGenInfo");n.onclick=()=>{let n=Array(t);n[0]=0;for(let d=1;d<t;++d){let r=e.slice(0,4*d);for(let o=0;o<5;++o)l(r);let s=performance.now();for(let m=0;m<100;++m)l(r);let h=performance.now();n[d]=(h-s)/100}let g=Math.min(...n),y=Math.max(...n),u=1/(y-g);i.style.display="block",i.width=t,i.height=t;let $=i.getContext("2d"),c=i.height;$.setTransform(1,0,0,-c*u,-g,c),$.clearRect(0,0,i.width,y),$.rect(0,0,i.width,y),$.fillStyle="#400778",$.fill();let v=i.width/(n.length-1);$.strokeStyle="#00d5ff";for(let w=0;w<n.length;++w){let B=v*w,p=n[w];$.beginPath(),$.moveTo(B,0),$.lineTo(B,p),$.stroke()}a.style.display="block",a.innerText=`Max lines: ${t} Max time: ${y}ms`},n.disabled=!1});</script> <hr id=footersep> <div id=copyright>With the exception of third-party libraries / resources, code is public domain. Text &copy; Alister Chowdhury.</div> <script>async function _hsInit(...e){for(let n of e){let t=document.createElement("script");t.src="/thirdparty/languages/"+n+".min.js",t.async=!0,t.onload=function(e){return function(){document.querySelectorAll("pre code.language-"+e).forEach(hljs.highlightElement)}}(n),document.body.appendChild(t)}}</script> <script async src=/thirdparty/highlight.min.js onload="_hsInit('c','glsl','python');"></script></body></html>