<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=author content="Alister Chowdhury"><meta name=theme-color content=#2b2b2b><link href=/css.css rel=stylesheet><meta property=og:site_name content="Stuff And Also Things"><meta name=viewport content="width=device-width, initial-scale=1"><link rel=icon type=image/png sizes=32x32 href=/res/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/res/favicon-16x16.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-1WDZZ2C662"></script><script>if(window.dataLayer=window.dataLayer||[],"alister-chowdhury.github.io"==window.location.hostname){function a(){dataLayer.push(arguments)}a("js",new Date),a("config","G-1WDZZ2C662")}</script><link rel=canonical href=https://alister-chowdhury.github.io/posts/20230710-2d-circular-shadow-mapping/><meta property=og:title content="2D Circular Shadow Mapping"><meta property=og:url content=https://alister-chowdhury.github.io/posts/20230710-2d-circular-shadow-mapping/><meta property=og:type content=article><meta property=og:description content="How to shadow map pointlights in a 2D scene using circles, in a similar way to traditional 3D shadow mapping, then extending that concept to using planes."><meta property=og:image content=https://alister-chowdhury.github.io/posts/20230710-2d-circular-shadow-mapping/thumbnail.png><meta property=og:article:published_time content=2023-07-10T00:00:00><meta property=og:article:tag content=shadows><meta property=og:article:tag content="shadow mapping"><meta property=og:article:tag content=lights><meta property=og:article:tag content=circles><meta property=og:article:tag content=visibility><meta property=og:article:tag content=2D><meta property=og:article:tag content=rendering><meta property=og:article:tag content=graphics><meta property=og:article:tag content=depth><script data-rh=true type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":[{"@type":"Person","name":"By Alister Chowdhury"}],"name":"2D Circular Shadow Mapping","url":"https://alister-chowdhury.github.io/posts/20230710-2d-circular-shadow-mapping/","description":"How to shadow map pointlights in a 2D scene using circles, in a similar way to traditional 3D shadow mapping, then extending that concept to using planes.","thumbnailUrl":"https://alister-chowdhury.github.io/posts/20230710-2d-circular-shadow-mapping/thumbnail.png","datePublished":"2023-07-10T00:00:00"}</script><title>2D Circular Shadow Mapping</title><meta name=description content="How to shadow map pointlights in a 2D scene using circles, in a similar way to traditional 3D shadow mapping, then extending that concept to using planes."><meta name=keywords content="shadows, shadow mapping, lights, circles, visibility, 2D, rendering, graphics, depth"><script>function addAfterCircularMappingModuleLoaded(a){window.circularMappingModuleLoaded?a():window.afterCircularMappingModuleLoaded.push(a)}window.circularMappingModuleLoaded=!1,window.afterCircularMappingModuleLoaded=[];</script><script type=module>import{bindCircularMappingContext as a}from"./circular_mapping.js";window.bindCircularMappingContext=a,window.circularMappingModuleLoaded=!0,window.afterCircularMappingModuleLoaded.forEach(a=>{a()});</script><style>.amdAsmCmp{display:flex;flex-wrap:wrap;justify-content:center;align-content:center}.amdAsmCmp>div{border:#7373c3 1px solid;margin:5px}.imComp>div>img{width:300px;width:300px}canvas{display:block;margin-left:auto;margin-right:auto}</style><link rel=stylesheet href=/thirdparty/highlight.js.css></head><body> <div id=header> <a href=/>Home</a> <a href=/posts/>Posts</a> <a href=https://github.com/alister-chowdhury>Github</a> </div> <div> <canvas id=drawCanvas style=width:500px;height:500px width=500 height=500></canvas><br> <div class=twoxnctrls id=drawCanvasControls> <div> <div id=resolutionCtrlDivLabel>Resolution</div> <div><input aria-labelledby=resolutionCtrlDivLabel id=resolutionCtrl disabled type=number min=1 max=2048 value=500 step=1><br></div> </div> <div> <div id=lineMapResCtrlDivLabel>Linemap Resolution</div> <div><div><input aria-labelledby=lineMapResCtrlDivLabel id=lineMapResCtrl disabled type=range min=5 max=11 value=9 step=1><div id=lineMapResVis>512</div></div><br></div> </div> <div> <div id=lightCountCtrlDivLabel># Lights</div> <div><input aria-labelledby=lightCountCtrlDivLabel id=lightCountCtrl disabled type=range min=1 max=100 value=10 step=1><div id=numLightsVis>10</div><br></div> </div> <div> <div id=drawLinesOverlayLabel>Draw lines</div> <div><input aria-labelledby=drawLinesOverlayLabel id=drawLinesOverlayCtrl disabled type=checkbox checked><br></div> </div> <div> <div id=drawBoundsOverlayLabel>Draw bounds</div> <div><input aria-labelledby=drawBoundsOverlayLabel id=drawBoundsOverlayCtrl disabled type=checkbox><br></div> </div> <div> <div>Scene</div> <div class=knkRadio> <input disabled type=radio id=sceneType-simple name=sceneType checked=checked><label for=sceneType-simple>Simple</label> <input disabled type=radio id=sceneType-moderate name=sceneType><label for=sceneType-moderate>Moderate</label> <input disabled type=radio id=sceneType-complex name=sceneType><label for=sceneType-complex>Complex</label> </div> </div> <div> <div>Bounds type</div> <div class=knkRadio> <input disabled type=radio id=boundsType-bbox name=boundsType><label for=boundsType-bbox>BBOX</label> <input disabled type=radio id=boundsType-obbox name=boundsType checked=checked><label for=boundsType-obbox>OBBOX</label> </div> </div> <div> <div>Filtering</div> <div class=knkRadio> <input disabled type=radio id=filtering-binary name=filtering><label for=filtering-binary>Binary</label> <input disabled type=radio id=filtering-pcf name=filtering checked=checked><label for=filtering-pcf>PCF</label> </div> </div> <div> <div id=lightSelectCtrlDivLabel>Select light</div> <div><input aria-labelledby=lightSelectCtrlDivLabel id=lightSelectCtrl disabled type=range min=0 max=49 value=0 step=1><br></div> </div> <div> <div id=lightColCtrlDivLabel>Light Colour</div> <div><input aria-labelledby=lightColCtrlDivLabel id=lightColCtrl disabled type=color value=#000000><br></div> </div> <div> <div id=lightIntensityCtrlDivLabel>Intensity</div> <div><input aria-labelledby=lightIntensityCtrlDivLabel id=lightIntensityCtrl disabled type=range min=0 max=10 value=1 step=0.01><br></div> </div> <div> <div id=lightDecayRateCtrlDivLabel>Decay Rate</div> <div><input aria-labelledby=lightDecayRateCtrlDivLabel id=lightDecayRateCtrl disabled type=range min=0.01 max=10 value=0 step=0.01><br></div> </div> </div> <div id=notSupportedBrowser></div> </div> <br> <main> <h1>2D Circular Shadow Mapping</h1> <div class=toc> <ul> <li><a href=#background>Background</a></li> <li><a href=#faster-atan2>Faster atan2</a></li> <li><a href=#generating-a-shadowmap>Generating A Shadowmap</a></li> <li><a href=#planemaps>Planemaps</a> <ul> <li><a href=#binary-sampling>Binary sampling</a></li> <li><a href=#pcf>PCF</a></li> </ul> </li> <li><a href=#filtering-lights-to-evaluate>Filtering Lights To Evaluate</a></li> <li><a href=#demo>Demo</a></li> </ul> </div> <h2 id=background>Background</h2> <p>Lighting a scene efficiently is pretty difficult in 3D and in 2D that is still the case. The de-facto standard for shadows has remained shadow mapping (and derivative techniques) for quite a number of years and that doesn't look like it will change any time soon.</p> <p>For 3D, you'd typically render the scene from the perspective of a light (or if it's a directional light, a cascade of orthographic projections that cover what the player can see), storing only the depth and sampling it when it comes time to apply lighting.</p> <p>We can do a similar thing for pointlights in 2D, by mapping the surface of a circle to a 1D texture.</p> <pre><code class=language-glsl>// u is the 1d texture coordinate (0 -&gt; 1)
vec2 circlePosition = vec2(cos(u * TWOPI), sin(u * TWOPI));
float u = atan2(circlePosition.y, circlePosition.x) / TWOPI;
</code></pre> <div id=circleToLineDemoContainer> <canvas id=circleToLineDemo></canvas> <div class=twoxnctrls> <div> <div id=circleToLineDemoLerpLabel>line &lt;=&gt; circle</div> <div><input aria-labelledby=circleToLineDemoLerpLabel id=circleToLineDemoLerp type=range min=0 max=1 value=0 step=0.0001><br></div> </div> </div> </div> <p>Storing information in this way has the added bonus, that we can store the shadow information of multiple lights in a single 2D texture, where each light is it's own row. So if we have 100 lights and we choose to have a resolution of 512, we allocate a single <code>512x100</code> texture, this simplifies binding and opens the door for evaluating all pointlights in a single pass.</p> <p><strong>If you have truly static lights, baking them all down either onto the background image or as a seperate overlay is always going to be faster at runtime.</strong></p> <h2 id=faster-atan2>Faster atan2</h2> <p>You may know that <code>atan2</code> is expensive, especially if it's something we plan on doing potentially multiple times per pixel. As such, we are going to want to use approximations.</p> <p>This is a pretty decent one I've found, courtesy of <a target=_blank href=https://math.stackexchange.com/a/1105038>njuffa on math.stackexchange.com</a>.</p> <details> <summary>fastAtan2</summary> <pre><code class=language-glsl>// https://math.stackexchange.com/a/1105038
float fastAtan2(float y, float x)
{
    float a = min(abs(x), abs(y)) / max(abs(x), abs(y));
    float s = a * a;
    float r = ((-0.0464964749 * s + 0.15931422) * s - 0.327622764) * s * a + a;
    if(abs(y) &gt; abs(x)) { r = HALFPI - r; }
    if(x &lt; 0) { r = PI - r; }
    r = multiplySign(r, y); // if(y &lt; 0) { r = -r; }
    return r;
}
</code></pre> </details> <p>But we can do a bit better since we also need to do an extra division by 2pi</p> <details> <summary>fastAtan2_div2pi</summary> <pre><code class=language-glsl>// Similar to fastAtan2, except the result is pre divided by 2pi, for the
// purpose of sampling 1d circular maps (circular shadows etc).
// https://www.geogebra.org/calculator/dms6kp8w
//
// max error ~ 0.00024531353567275316
float fastAtan2_div2pi(float y, float x)
{
    float a = min(abs(x), abs(y)) / max(abs(x), abs(y));
    float s = a * a;
    float r = ((0.013506162438972577 * s + -0.04684240210645093) * s + -0.8414151531876038) * a + a;
    if(abs(y) &gt; abs(x)) { r = 0.25 - r; }
    if(x &lt; 0.0) { r = 0.5 - r; }
    r = multiplySign(r, y); // if(y &lt; 0) { r = -r; }
    return r;
}

</code></pre> </details> <p>And if we wanted to be extra accurate (we don't):</p> <details> <summary>fastAtan2_div2pi_accurate</summary> <pre><code class=language-glsl>// One extra mad over fastAtan2_div2pi, although that is typically accurate enough.
//
// max error ~ 3.6957397769599165e-05
float fastAtan2_div2pi_accurate(float y, float x)
{
    float a = min(abs(x), abs(y)) / max(abs(x), abs(y));
    float s = a * a;
    float r = (((-0.0066609612639593 * s + 0.023972538405749075) * s + -0.05140823187987065) * s + -0.8409411267732256) * a + a;
    if(abs(y) &gt; abs(x)) { r = 0.25 - r; }
    if(x &lt; 0.0) { r = 0.5 - r; }
    r = multiplySign(r, y); // if(y &lt; 0) { r = -r; }
    return r;
}
</code></pre> </details> <p>I wrote the following python script using <code>scipy.optimize.curve_fit</code> to derive the coefficients (not particularly well written, but this is very much something you run once and never touch again, but probably nice to have a reference):</p> <details> <summary>atan01.py</summary> <pre><code class=language-python>from numpy import *
from scipy.optimize import curve_fit

ACCURATE = False

if ACCURATE:
    def atan01_func(X, *betas):
        a = X # y/x
        s = a * a
        return (((betas[0] * s + betas[1]) * s + betas[2]) * s + betas[3]) * a + a

else:
    def atan01_func(X, *betas):
        a = X # y/x
        s = a * a
        return ((betas[0] * s + betas[1]) * s + betas[2]) * a + a


if __name__ == &quot;__main__&quot;:
    B = linspace(0.0, 1.0, 20000)
    P = stack((cos(B * 2 * pi), sin(B * 2 * pi)))
    Px = P[0]
    Py = P[1]

    # Lazily isolate one quadrant of a cicle
    keep = (Px &gt; 0) &amp; (Py &gt; 0) &amp; (Px &gt; Py)
    Px = Px[keep]
    Py = Py[keep]
    
    # Fitting ratio of segment
    fit_x = Py / Px
    fit_y = arctan2(Py, Px) / (2 * pi)

    best = float(&quot;inf&quot;)
    best_coefs = None

    for _ in range(10):
        if ACCURATE:
            initial_seed = random.random(4) * 20 - 10
        else:
            initial_seed = random.random(3) * 20 - 10
        try:
            coefs = curve_fit(atan01_func, fit_x, fit_y, initial_seed)[0]
        except RuntimeError:
            # Ignore when convergence couldn't be resolved
            continue
        yhat = atan01_func(fit_x, *coefs)
        diff = abs(fit_y - yhat).max()
        if diff &lt; best:
            best = diff
            best_coefs = coefs

    print(&quot;ACC {0}&quot;.format(best))
    print(&quot;\nCoefs:&quot;)
    for f in best_coefs:
        print(f)
</code></pre> </details> <p>Before and after AMD assembly for reference:</p> <div class=amdAsmCmp> <div> <pre><code>v_max_f32     v1, abs(v2), abs(v0)
v_rcp_f32     v1, v1
v_min_f32     v3, abs(v2), abs(v0)
v_mul_f32     v1, v1, v3
v_mul_f32     v3, v1, v1
v_mul_f32     v4, 0x3caaae5f, v3
v_add_f32     v4, 0xbdae5a36, v4
v_madak_f32   v4, v3, v4, 0x3e3876e2
v_madak_f32   v4, v3, v4, 0xbea91d04
v_madak_f32   v3, v3, v4, 0x3f7ff738
v_mul_f32     v4, v1, v3
v_madak_f32   v4, -2.0, v4, 0x3fc90fdb
v_cmp_gt_f32  vcc, abs(v0), abs(v2)
v_cndmask_b32  v4, 0, v4, vcc
v_min_f32     v5, v2, v0
v_max_f32     v0, v2, v0
v_cmp_gt_f32  vcc, -v2, v2
v_mov_b32     v2, 0xc0490fdb
v_cmp_gt_f32  s[0:1], -v5, v5
v_cmp_ge_f32  s[2:3], v0, -v0
v_mac_f32     v4, v1, v3
v_cndmask_b32  v0, 0, v2, vcc
s_and_b64     vcc, s[0:1], s[2:3]
v_mov_b32     v1, 0x80000000
v_add_f32     v0, v4, v0
v_cndmask_b32  v1, 0, v1, vcc
v_xor_b32     v0, v0, v1
v_mul_f32     v0, 0.15915494, v0
</code></pre> </div> <div> <pre><code>v_min_f32     v1, abs(v2), abs(v0)
v_max_f32     v3, abs(v2), abs(v0)
v_rcp_f32     v3, v3
v_mul_f32     v1, v1, v3
v_mul_f32     v3, v1, v1
v_mul_f32     v4, 0x3c5d48f3, v3
v_add_f32     v4, 0xbd3fddd2, v4
v_madak_f32   v3, v4, v3, 0xbf5766fc
v_mac_f32     v1, v3, v1
v_sub_f32     v3, 0x3e800000, v1
v_cmp_gt_f32  vcc, abs(v2), abs(v0)
v_cndmask_b32  v1, v1, v3, vcc
v_sub_f32     v3, 0.5, v1
v_cmp_gt_f32  vcc, 0, v0
v_cndmask_b32  v0, v1, v3, vcc
v_and_b32     v1, 0x80000000, v2
v_xor_b32     v0, v0, v1
</code></pre> </div> </div> <h2 id=generating-a-shadowmap>Generating A Shadowmap</h2> <p>If you've got a BVH of the scene (<a href=https://alister-chowdhury.github.io/posts/20230620-raytracing-in-2d/>Raytracing In 2D</a>), you can very quickly generate your maps.</p> <pre><code class=language-glsl>// Assuming you're just doing a fullscreen pass with the vertex shader
// that outputs the screen uv coordinate and have a uniform buffer of pointlight
// coordinates.

layout(location=0) in vec2 uv;
layout(location=0) out float outDepth; // Or write to gl_FragDepth, both would work.

void main()
{

    int lightId = int(gl_FragCoord.y);
    vec2 ro = getLightPosition(lightId);
    vec2 rd = vec2(cos(uv.x * TWOPI), sin(uv.x * TWOPI));

    LineBvhV1Result hit = traceLineBvhV1(ro, rd, 1.0, false);

    outDepth = sqrt(hit.hitDistSq);

    // Needs to be normalised between 0-&gt;1 to work
    // gl_FragDepth = 1.0 - 1.0 / (1.0 + length(I));
}
</code></pre> <p>Now if you aren't interested in generating a BVH, you can also use lines directly, but it is a bit more involved. The basic idea is to draw each line over each pointlights row, then manually overriding <code>gl_FragDepth</code>, allowing the GPUs depth hardware to store the closest hit.</p> <p>For this example, I'm using <code>glDrawArraysInstanced</code>, with the vertex id encoding the light and instance id encoding the line. (We also need to draw each line twice, since it's liable to wrap around).</p> <details> <summary>vertex shader</summary> <pre><code class=language-glsl>layout(location = 0) uniform float invTextureHeight;

flat layout(location = 0) out vec4 lineData;
layout(location = 1) out float direction;


void main()
{
    // Lines need to be duplicated so we can effectively wrap around
    // when projected lines aren't simply in the 0-&gt;1 range and are in the
    // -1-&gt;0 range.
    const float polarOffset = float(gl_InstanceID &amp; 1);
    const uint pointLightID = startingPointLightID + gl_InstanceID &gt;&gt; 1;

    const uint lineId = gl_VertexID &gt;&gt; 1;
    const uint lineSide = gl_VertexID &amp; 1;

    const vec2 light = getLightPosition(pointLightID);
    vec4 line = getLine(lineId) - light.xyxy; // Make sure the line is always relative to the light

    // x = A, y = B
    vec2 polarPositions = vec2(fastAtan2_div2pi(line.y, line.x),
                               fastAtan2_div2pi(line.w, line.z));


    // Make sure the points are the minimum circular distance
    #if 0 // reference
        if(polarPositions.y &lt; polarPositions.x) {
            polarPositions.x -= sign(polarPositions.x) * float(abs(polarPositions.y - polarPositions.x) &gt; 0.5);
        }
        else {
            polarPositions.y -= sign(polarPositions.y) * float(abs(polarPositions.x - polarPositions.y) &gt; 0.5);
        }
    #else // branchless
        polarPositions -= (
            vec2(lessThan(polarPositions.yx, polarPositions.xy))
            * sign(polarPositions)
            * vec2(greaterThan(abs(polarPositions - polarPositions.yx), vec2(0.5)))
        );
    #endif

    // In order to make everything airtight (so no holes where lines meet)
    // the lines need to have a consistent winding order, to get around
    // this, we can instead opt to make sure our line coords are sorted.
    if(polarPositions.y &lt; polarPositions.x)
    {
        float tmp = polarPositions.x;
        polarPositions.x = polarPositions.y;
        polarPositions.y = tmp;

        vec2 tmpl = line.xy;
        line.xy = line.zw;
        line.zw = tmpl;
    }

    // Apply wrap-around offset
    polarPositions += polarOffset;

    // Swap between A and B points
    const float X = ((lineSide == 0) ? polarPositions.x : polarPositions.y);

    lineData = ((lineSide == 0) ? line.xyzw : line.zwxy);
    direction = TWOPI * (X - 0.5);

    gl_Position = vec4(2 * X - 1,
                       2 * ((0.5 + float(pointLightID)) * invTextureHeight) - 1,
                       0.0,
                       1.0);
}
</code></pre> </details> <br> <details> <summary>fragment shader</summary> <pre><code class=language-glsl>flat layout(location = 0) in vec4 lineData;
layout(location = 1) in float direction;

void main()
{
    // Calculate the distance from the origin when facing in a direction
    // dictated by the polar coordinates to the target line.
    // https://www.geogebra.org/m/pabfs2c9
    vec2 directionVec = vec2(cos(direction), sin(direction));

    vec2 lineDiff = lineData.zw - lineData.xy;
    float u = (
        (directionVec.x * lineData.y - directionVec.y * lineData.x)
        / (lineDiff.x * directionVec.y - lineDiff.y * directionVec.x)
    );

    vec2 I = lineData.xy + lineDiff * u;
    gl_FragDepth = 1.0 - 1.0 / (1.0 + length(I));
}
</code></pre> </details> <p>Overall, using the BVH version is probably a better option.</p> <p>Now we can start attempting to shadow things. Normally for shadow maps you'd use something like PCF when sampling, which we can get the hardware to do directly when using a depth texture (it's not hard to do manually if you're rendering to some other format).</p> <details> <summary>texture parameters</summary> <pre><code class=language-c>glTextureParameteri(tex, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTextureParameteri(tex, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

if(useHardwarePCF)
{
    glTextureParameteri(tex, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTextureParameteri(tex, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTextureParameteri(tex, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);
    glTextureParameteri(tex, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE);
}

// manual PCF
else
{
    glTextureParameteri(tex, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTextureParameteri(tex, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
}
</code></pre> </details> <p>For the sake of keeping this simple, I'll assume we're using a depth texture and here are the parameters to enable PCF.</p> <p>Here is one way, you might go about applying the lights in a single fullscreen pass:</p> <details> <summary>lighting pass</summary> <pre><code class=language-glsl>layout(location = 0) uniform uint pointLightCount;
layout(binding = 0) uniform sampler2DShadow pointLightShadowMap;

layout(location = 0) in vec2 uv;
layout(location = 0) out vec4 outRgba;

void main()
{

    const vec2 invTextureSize = 1.0 / vec2(textureSize(pointLightShadowMap, 0));
    const float textureWidth = vec2(textureSize(pointLightShadowMap, 0)).x;

    vec3 totalAccum = vec3(0.0);

    for(uint pointLightID=0; pointLightID &lt; pointLightCount; ++pointLightID)
    {
        
        const vec2 pointLightPos = getLightPosition(pointLightID);
        const vec2 localUv = (2.0 * uv - 1.0) - pointLightPos.xy;   // assuming lights are in NDC space

        const float X = fastAtan2_div2pi(localUv.y, localUv.x);
        const float Y = (0.5 + float(pointLightID)) * invTextureSize.y;
        const float Z = 1.0 - 1.0 / (1.0 + length(localUv));
        float pcf = texture(pointLightShadowMap, vec3(X, Y, Z));
        totalAccum += evaluateLight(pointLightID, localUv) * pcf;
    }

    outRgba = vec4(totalAccum, 1.0);
}
</code></pre> </details> <br> <div class="imTable imComp"> <div><img alt=example1 src=res/example1.png><br>Single light source</div> </div> <br> <p>This may all look fine at first, but all is not how it seems...<br> If we move our light source and zoom in a bit, the true horror of acne reveals itself.</p> <div class="imTable imComp"> <div><img alt=acne0 src=res/acne0.png><br>Reference</div> <div><img alt=acne1 src=res/acne1.png><br>Zoomed in #1</div> <div><img alt=acne2 src=res/acne2.png><br>Zoomed in #2</div> </div> <br> <p>This does make sense, since each sample more-or-less maps to a radius of visibility and any direction in between doesn't really correspond to either in a linear way.</p> <p>You can of course just up the resolution, but this isn't a very satisfying solution.</p> <p>You might attempt to create lines between depth samples and then do line-line intersection tests, or even just render a line directly and this does work to some extent, but looks pretty bad when you get to the lines end points.</p> <p>A nicer solution I've found is to use <a target=_blank href=https://en.wikipedia.org/wiki/Hesse_normal_form>Hesse Normal Form</a> (basically planes).</p> <h2 id=planemaps>Planemaps</h2> <p>The idea is to store the equation of the line rather than its distance. It's not massively different pipeline wise to make the switch, although a bit more involved.</p> <p>Using <code>R10G10B10A2</code> is a natural fit, with <code>N</code> being stored in <code>RG</code> and <code>dist</code> being stored in <code>B</code> (not currently using <code>A</code>, but it could easily be used to store a more precise <code>dist</code>).</p> <p>We could also opt for <code>RG16F</code>, storing a polar angle in <code>R</code> and the dist in <code>G</code>.</p> <p>As a reminder, no GPU actually supports the &quot;regular&quot; three-component texture formats (<code>RGB8</code>, <code>RGB16</code>, <code>RGB16F</code>, <code>RGB32F</code>), they are simply padded and the hidden <code>A</code> is basically dead space.</p> <pre><code class=language-glsl>layout(location=0) in vec2 uv;
layout(location=0) out vec4 outPlane;

void main()
{
    int lightId = int(gl_FragCoord.y);
    vec2 ro = getLightPosition(lightId);
    vec2 rd = vec2(cos(uv.x * TWOPI), sin(uv.x * TWOPI));
    LineBvhV1Result hit = traceLineBvhV1(ro, rd, 1.0, false);

    vec2 N = rd;
    float w = 1.0;

    if(hit.hitLineId != 0xffffffffu)
    {
        N = normalize(vec2(hit.line.w, -hit.line.z));
        w = dot(N, hit.line.xy - ro);
        
        // Ensure a consistent clockwise orientation plus
        // keep the distance coef positive.
        N.x = multiplySign(N.x, w);
        N.y = multiplySign(N.y, w);
        w = multiplySign(w, w);
    }

    // R10G10B10A2 encoding, A2 is currently unused...
    outPlane = vec4(N * 0.5 + 0.5, w, 1.0);
}
</code></pre> <p>When it comes to sampling, there are two flavours that I've found work well.</p> <h3 id=binary-sampling>Binary sampling</h3> <p>This is by far the simplest method and works rather well, it can feel a bit jittery though and break down a tad when there is a sharp change in orientation.</p> <pre><code class=language-glsl>float getBinaryPlaneVisibility(vec2 uv, vec3 sampledNormalAndDistance, float bias /* = 0.5 / lightPlaneMapSize.x */)
{
    return 1.0 - smoothstep(sampledNormalAndDistance.z - bias,
                            sampledNormalAndDistance.z + bias,
                            dot(uv, sampledNormalAndDistance.xy));
}
</code></pre> <h3 id=pcf>PCF</h3> <p>Can look better when the linemap resolution is very low, but overall <strong>Binary sampling</strong> should probably be preferred.</p> <pre><code class=language-glsl>// Two taps and two binary plane tests, texture width is assumed to be a power of 2,
// more expensive, but generally just looks better.
float getPCFPlaneVisibility(sampler2D lightPlaneMap,
                            vec2 localUv, // uv local to the lights center
                            vec2 planeMapUV,
                            ivec2 lightPlaneMapSize,
                            float bias /* = 0.5 / lightPlaneMapSize.x */)
{
    float sampleXBase = (planeMapUV.x + 1.0) * lightPlaneMapSize.x - 0.5;
    int sampleY = int(planeMapUV.y * lightPlaneMapSize.y);
    
    int sampleX0 = int(sampleXBase);
    int sampleX1 = sampleX0 + 1;
    sampleX0 &amp;= (lightPlaneMapSize.x - 1);
    sampleX1 &amp;= (lightPlaneMapSize.x - 1);

    vec3 planeAndDistance0 = texelFetch(lightPlaneMap, ivec2(sampleX0, sampleY), 0).xyz;
    vec3 planeAndDistance1 = texelFetch(lightPlaneMap, ivec2(sampleX1, sampleY), 0).xyz;
    planeAndDistance0.xy = planeAndDistance0.xy * 2.0 - 1.0;
    planeAndDistance1.xy = planeAndDistance1.xy * 2.0 - 1.0;

    float visbility0 = getBinaryPlaneVisibility(localUv, planeAndDistance0, bias);
    float visbility1 = getBinaryPlaneVisibility(localUv, planeAndDistance1, bias);

    float lerpWeight = fract(sampleXBase);
          lerpWeight = smoothstep(0, 1, lerpWeight);
    return mix(visbility0, visbility1, lerpWeight);
}
</code></pre> <h2 id=filtering-lights-to-evaluate>Filtering Lights To Evaluate</h2> <p>Up until this point, we've been evaluating every light per pixel, this is not going to scale well beyond a handful of lights.</p> <p>The first obvious optimisation would be to only evaluate pixels the player sees (<a href=https://alister-chowdhury.github.io/posts/20230628-project-and-stencil/>Blocking 2D Player Visibility</a>), although this might not always be possible.</p> <p>We can generate bounds for each light, using the planemaps we've already generated and draw a series of quads which add the colour to the scene.</p> <p>(If we weren't targeting WebGL and had compute shaders / UAV buffers, using a linked light list would be a sensible option).</p> <p>The simplest option is to generate BBOXs:</p> <details> <summary>gen_bbox.frag</summary> <pre><code class=language-glsl>vec2 projectRay(vec3 planeAndDistance, float theta)
{
    vec2 rd = vec2(cos(theta), sin(theta));
    float denom = dot(planeAndDistance.xy, rd);

    // Prevent divisions by zero and excessive expansion at grazing angles
    float onedeg = 0.01745240643728351;
    if(abs(denom) &lt;= onedeg)
    {
        return vec2(0);
    }

    float distToPlane = planeAndDistance.z / denom;
    return rd * distToPlane;
}


void main()
{
    int lineIndex = int(gl_FragCoord.x);
    vec2 ro = getLightPosition(lightingData, lineIndex);
    vec2 bboxMax = vec2(-65504.0);
    vec2 bboxMin = vec2(65504.0);

    // Assumed linemap resolution to be a power of 2
    int lightPlaneMapWidth = textureSize(lightPlaneMap, 0).x;
    float invTextureSizeTwoPi = rcpForPowersOf2(float(lightPlaneMapWidth)) * TWOPI;

    for(int x=0; x &lt; lightPlaneMapWidth; ++x)
    {

        vec3 planeAndDistance = texelFetch(lightPlaneMap, ivec2(x, lineIndex), 0).xyz;
             planeAndDistance.xy = planeAndDistance.xy * 2 - 1;

        // Project against the left and right rotational values
        // to prevent underprojecting and not fully containing
        // the light.

        const float bias = 1.0;

        float thetaLeft = (float(x) - bias) * invTextureSizeTwoPi;
        float thetaRight = (float(x) + bias) * invTextureSizeTwoPi;

        vec2 projectionLeft = projectRay(planeAndDistance, thetaLeft);
        vec2 projectionRight = projectRay(planeAndDistance, thetaRight);

        bboxMin = min(min(projectionLeft, projectionRight), bboxMin);
        bboxMax = max(max(projectionLeft, projectionRight), bboxMax);
    }

    outBBox = vec4(bboxMin + ro, bboxMax + ro);
}
</code></pre> </details> <br> <p>This works reasonably well, but we can prevent overdrawing by fitting a better quad:</p> <details> <summary>gen_obbox.frag</summary> <pre><code class=language-glsl>vec2 projectRay(vec3 planeAndDistance, float theta)
{
    vec2 rd = vec2(cos(theta), sin(theta));
    float denom = dot(planeAndDistance.xy, rd);

    // Prevent divisions by zero and excessive expansion at grazing angles
    float onedeg = 0.01745240643728351;
    if(abs(denom) &lt;= onedeg)
    {
        return vec2(0);
    }

    float distToPlane = planeAndDistance.z / denom;
    return rd * distToPlane;
}


void main()
{
    int lineIndex = int(gl_FragCoord.x);
    vec2 ro = getLightPosition(lightingData, lineIndex);

    // Assumed linemap resolution to be a power of 2
    int lightPlaneMapWidth = textureSize(lightPlaneMap, 0).x;
    float invTextureSizeTwoPi = rcpForPowersOf2(float(lightPlaneMapWidth)) * TWOPI;

    const float bias = 1.0;

    // Find initial furthest vector
    vec2 furthest = vec2(0);
    float furthestDistSq = -65504.0;

    for(int x=0; x &lt; lightPlaneMapWidth; ++x)
    {
        vec3 planeAndDistance = texelFetch(lightPlaneMap, ivec2(x, lineIndex), 0).xyz;
             planeAndDistance.xy = planeAndDistance.xy * 2 - 1;

        float thetaLeft = (float(x) - bias) * invTextureSizeTwoPi;
        vec2 projectionLeft = projectRay(planeAndDistance, thetaLeft);
        float leftDistSq = dot(projectionLeft, projectionLeft);
        float thetaRight = (float(x) + bias) * invTextureSizeTwoPi;
        vec2 projectionRight = projectRay(planeAndDistance, thetaRight);
        float rightDistSq = dot(projectionRight, projectionRight);

        if(leftDistSq &gt; furthestDistSq)
        {
            furthest = projectionLeft;
            furthestDistSq = leftDistSq;
        }

        if(rightDistSq &gt; furthestDistSq)
        {
            furthest = projectionRight;
            furthestDistSq = rightDistSq;
        }
    }

    // Next find the furthest point from our first point
    vec2 furthestTangent = vec2(0);
    float furthestTangentDistSq = -65504.0;

    for(int x=0; x &lt; lightPlaneMapWidth; ++x)
    {
        vec3 planeAndDistance = texelFetch(lightPlaneMap, ivec2(x, lineIndex), 0).xyz;
             planeAndDistance.xy = planeAndDistance.xy * 2 - 1;

        float thetaLeft = (float(x) - bias) * invTextureSizeTwoPi;
        vec2 projectionLeft = projectRay(planeAndDistance, thetaLeft);
        float leftDistSq = dot(projectionLeft - furthest, projectionLeft - furthest);
        float thetaRight = (float(x) + bias) * invTextureSizeTwoPi;
        vec2 projectionRight = projectRay(planeAndDistance, thetaRight);
        float rightDistSq = dot(projectionRight - furthest, projectionRight - furthest);

        if(leftDistSq &gt; furthestTangentDistSq)
        {
            furthestTangent = projectionLeft;
            furthestTangentDistSq = leftDistSq;
        }

        if(rightDistSq &gt; furthestTangentDistSq)
        {
            furthestTangent = projectionRight;
            furthestDistSq = rightDistSq;
        }
    }

    vec2 L0 = furthest;
    vec2 L1 = furthestTangent;

    // All remaining points should lie either left or right of our computed line
    float CDist = 0.0;
    float DDist = 0.0;

    vec2 Ld = normalize(L1 - L0);
    vec2 Ln = vec2(Ld.y, -Ld.x);
    float Lw = dot(Ln, L0);

    for(int x=0; x &lt; lightPlaneMapWidth; ++x)
    {
        vec3 planeAndDistance = texelFetch(lightPlaneMap, ivec2(x, lineIndex), 0).xyz;
             planeAndDistance.xy = planeAndDistance.xy * 2 - 1;

        float thetaLeft = (float(x) - bias) * invTextureSizeTwoPi;
        vec2 projectionLeft = projectRay(planeAndDistance, thetaLeft);
        float leftDist = dot(projectionLeft, Ln) - Lw;
        
        float thetaRight = (float(x) + bias) * invTextureSizeTwoPi;
        vec2 projectionRight = projectRay(planeAndDistance, thetaRight);
        float rightDist = dot(projectionRight, Ln) - Lw;

        if(leftDist &lt; 0)
        {
            if(abs(leftDist) &gt; abs(CDist))
            {
                CDist = leftDist;
            }
        }
        else
        {
            if(leftDist &gt; DDist)
            {
                DDist = leftDist;
            }
        }

        if(rightDist &lt; 0)
        {
            if(abs(rightDist) &gt; abs(CDist))
            {
                CDist = rightDist;
            }
        }
        else
        {
            if(rightDist &gt; DDist)
            {
                DDist = rightDist;
            }
        }
    }

    vec2 A = furthest + Ln * CDist;
    vec2 B = furthest + Ln * DDist;
    vec2 C = furthestTangent + Ln * DDist;
    vec2 D = furthestTangent + Ln * CDist;

    outOOBox = uvec4(packHalf2x16(A + ro),
                     packHalf2x16(B + ro),
                     packHalf2x16(C + ro),
                     packHalf2x16(D + ro));
}
</code></pre> </details> <br> <p>The above stores four points, but in order to make it easier to fetch, packs them as <code>float16</code>.</p> <br> <p>Despite the <code>bbox</code> code iterating every pixel in a row (and the <code>obbox</code> iterating them three times), this is actually remarkably not the most obscenely expensive operation to run, of course ideally you'd run the whole operation maybe once and update individual lights as data changes.</p> <p>If we have stationary lights which change intensity / colour, but not be moved, offline generating polygons and not using shadow mapping at all would result in the fastest solution (although that's not exactly simple to do and very beyond the scope of what we're attempting to do here).</p> <p>Regardless, one of the main bottlenecks to expect here is the amount of lights that overlap the same pixel, as this increases the amount of implicit dependencies the GPU will need to resolve when blending (a complex scene may then actually be cheaper to evaluate).</p> <h2 id=demo>Demo</h2> <p>Here are all the relevant source code files for the demo at the top:</p> <ul> <li>JS used for demo: <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/circular_mapping.js>circular_mapping.js</a></li> <li>Shader used for demo:</li> <li><ul> <li>Plane generation: <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/gen_plane_map.frag>gen_plane_map.frag</a></li> </ul> </li> <li><ul> <li>BBox calculation: <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/gen_bbox.frag>gen_bbox.frag</a></li> </ul> </li> <li><ul> <li>OBBox calculation: <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/gen_obbox.frag>gen_obbox.frag</a></li> </ul> </li> <li><ul> <li>Light drawing: <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/draw_lights.frag>draw_lights.frag</a>, <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/draw_lights.vert>draw_lights.vert</a>, <a target=_blank href=https://github.com/alister-chowdhury/alister-chowdhury.github.io/blob/master/_source/posts/20230710-2d-circular-shadow-mapping/shaders/lights_common.glsli>lights_common.glsli</a></li> </ul> </li> </ul> </main> <script>const initCircleToLineDemo=()=>{let e=document.getElementById("circleToLineDemo"),t=document.getElementById("circleToLineDemoLerp"),n=e.getContext("2d");e.style.width="300px",e.style.height="300px",e.width=300,e.height=300;let l=()=>{let e=t.value,l=.05,i=.05*(2*Math.PI);n.clearRect(0,0,300,300),n.rect(0,0,300,300),n.fillStyle="#400778",n.fill();let r=e=>{let t=e=>Math.floor(.5+255*Math.max(0,Math.min(1,e))).toString(16).padStart(2,"0"),n=t(Math.abs(6*e-3)-1),l=t(2-Math.abs(6*e-2)),i=t(2-Math.abs(6*e-4));return"#"+n+l+i};for(let a=0;a<20;++a){let o=a+.5,d=.05*o,s=.5*Math.cos(o*i)+.5,u=.5*Math.sin(o*i)+.5,g=(d*(1-e)+s*e)*290+5,m=(.5*(1-e)+u*e)*290+5;n.beginPath(),n.arc(g,m,5,0,2*Math.PI),n.fillStyle=r(.5*d),n.fill()}};l(),t.onchange=l,t.oninput=l};initCircleToLineDemo();{let e=Math.round(.6*Math.min(window.innerHeight||document.documentElement.clientHeight,window.innerWidth||document.documentElement.clientWidth)),t=document.getElementById("resolutionCtrl");e=Math.min(t.max,Math.max(t.min,Math.round(e))),t.value=e;let n=document.getElementById("drawCanvas");n.style.width=e+"px",n.style.height=e+"px"}addAfterCircularMappingModuleLoaded(()=>{let e=document.getElementById("drawCanvas"),t=window.bindCircularMappingContext(e);if(t.valid)t.resourceLoaded.then(()=>{let n=document.getElementById("resolutionCtrl");n.disabled=!1;let l=()=>{let l=Math.min(n.max,Math.max(n.min,Math.round(n.value)));n.value!=l&&(n.value=l),e.style.width=l+"px",e.style.height=e.style.width,t.redraw()};n.onchange=l;let i=document.getElementById("lineMapResCtrl"),r=document.getElementById("lineMapResVis"),a=()=>{let e=1<<i.value;r.innerText=e,t.newPlaneMapResolution=e,t.redraw()};i.disabled=!1,i.oninput=a,i.onchange=a;let o=document.getElementById("lightCountCtrl"),d=document.getElementById("lightSelectCtrl"),s=document.getElementById("lightColCtrl"),u=document.getElementById("lightIntensityCtrl"),g=document.getElementById("lightDecayRateCtrl"),m=document.getElementById("numLightsVis"),h=()=>{let e=e=>Math.floor(255*e+.5).toString(16).padStart(2,"0"),n=t=>"#"+e(t[0])+e(t[1])+e(t[2]),l=t.lights[d.value];s.value=n(l.colour),u.value=l.intensity,g.value=l.decayRate};d.disabled=!1,d.onchange=h,d.oninput=h,d.max=t.currentNumLightsToRender-1,d.value=0,h();let c=()=>{let e=1*o.value;t.newNumLightsToRender=e,d.value>=e&&(d.value=e-1,h()),d.max=e-1,m.innerText=e,t.redraw()};o.disabled=!1,o.max=t.maxLights,o.value=t.currentNumLightsToRender,o.onchange=c,o.oninput=c,m.innerText=t.currentNumLightsToRender;let $=()=>{let e=d.value,n=t.lights[e],l=e=>[parseInt(e.substring(1,3),16)/255,parseInt(e.substring(3,5),16)/255,parseInt(e.substring(5,7),16)/255];n.colour=l(s.value),n.intensity=u.value,n.decayRate=g.value,t.dirtyLights.push(e),t.redraw()};i.disabled=!1,i.oninput=a,i.onchange=a,[s,u,g].forEach(e=>{e.disabled=!1,e.oninput=$,e.onchange=$});let y=document.getElementById("drawLinesOverlayCtrl");y.disabled=!1,y.onchange=()=>{t.drawLines=y.checked,t.redraw()};let v=document.getElementById("drawBoundsOverlayCtrl");v.disabled=!1,v.onchange=()=>{t.drawBounds=v.checked,t.redraw()};let _=["simple","moderate","complex"];for(let p=0;p<_.length;++p){let E=p,w=document.getElementById("sceneType-"+_[p]);w.disabled=!1,w.onchange=()=>{t.newScene=E,t.redraw()}}let b=["bbox","obbox"];for(let L=0;L<b.length;++L){let B=1==L,x=document.getElementById("boundsType-"+b[L]);x.disabled=!1,x.onchange=()=>{t.newUsingOBbox=B,t.redraw()}}let I=["binary","pcf"];for(let C=0;C<I.length;++C){let f=1==C,T=document.getElementById("filtering-"+I[C]);T.disabled=!1,T.onchange=()=>{t.usePCF=f,t.redraw()}}let R=(n,l)=>{n.preventDefault();let i=l?[n.touches[0].clientX,n.touches[0].clientY]:[n.clientX,n.clientY],r=e.getBoundingClientRect(),a=[(i[0]-r.x)/r.width,1-(i[1]-r.y)/r.height],o=d.value;t.lights[o].position=a,t.dirtyLights.push(o),t.redraw()},S=t=>{if("mousedown"==t.type){let n=e=>{R(e,!1)},l=t=>{t.preventDefault(),e.removeEventListener("mousemove",n,!1),e.removeEventListener("mouseup",l,!1)};e.addEventListener("mousemove",n,!1),e.addEventListener("mouseup",l,!1),n(t)}else{let i=e=>{R(e,!0)},r=t=>{t.preventDefault(),e.removeEventListener("touchmove",i,!1),e.removeEventListener("touchend",r,!1)};e.addEventListener("touchmove",i,!1),e.addEventListener("touchend",r,!1),i(t)}};e.addEventListener("mousedown",S,!1),e.addEventListener("touchstart",S,!1)});else{e.style.display="none",document.getElementById("drawCanvasControls").style.display="none";var n=document.getElementById("notSupportedBrowser");n.style.display="block",n.innerHTML=` Sorry, this demo won't work on your browser.<br> Reason: <strong>WebGL2 not supported :(</strong><br>`;return}});</script> <hr id=footersep> <div id=copyright>With the exception of third-party libraries / resources, code is public domain. Text &copy; Alister Chowdhury.</div> <script>async function _hsInit(...e){for(let n of e){let t=document.createElement("script");t.src="/thirdparty/languages/"+n+".min.js",t.async=!0,t.onload=function(e){return function(){document.querySelectorAll("pre code.language-"+e).forEach(hljs.highlightElement)}}(n),document.body.appendChild(t)}}</script> <script async src=/thirdparty/highlight.min.js onload="_hsInit('c','glsl','python');"></script></body></html>